import{M as k,Q as I}from"./index-B_3ZAKuN.js";function Ht(){return{4:{F:"#44ee00",D:"#f4f400",L:"#ff0000",R:"#2266ff"},6:{U:"#ffffff",F:"#44ee00",R:"#ff0000",D:"#f4f400",B:"#2266ff",L:"#ff8000"},8:{U:"#ffffff",F:"#44ee00",R:"#ff0000",D:"#f4f400",BB:"#2266ff",L:"#8800dd",BL:"#ff8000",BR:"#888888"},12:{U:"#ffffff",F:"#008800",R:"#ff0000",C:"#e8d0a0",A:"#3399ff",L:"#8800dd",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#f4f400",I:"#ff8000",D:"#888888"},20:{R:"#f4f400",C:"#d41f69",F:"#008800",E:"#5c5c5c",L:"#8800dd",U:"#ffffff",A:"#007a89",G:"#ff0000",I:"#7d3b11",S:"#b9a1ff",H:"#3399ff",J:"#5ec4b6",B:"#44ee00",K:"#e8d0a0",D:"#aaaaaa",M:"#ff66cc",O:"#292929",P:"#ff8000",N:"#980000",Q:"#0000ff"}}}class dt{constructor(t,e){this.facenames=t,e&&(this.gripnames=e);for(let s=0;this.prefixFree&&s<t.length;s++)for(let n=0;this.prefixFree&&n<t.length;n++)s!==n&&t[s].startsWith(t[n])&&(this.prefixFree=!1)}prefixFree=!0;gripnames=[];setGripNames(t){this.gripnames=t}splitByFaceNames(t){const e=[];let s=0;for(;s<t.length;){s>0&&s<t.length&&t[s]==="_"&&s++;let n=-1;for(let i=0;i<this.facenames.length;i++)t.substr(s).startsWith(this.facenames[i])&&(n<0||this.facenames[i].length>this.facenames[n].length)&&(n=i);if(n>=0)e.push(n),s+=this.facenames[n].length;else throw new Error(`Could not split ${t} into face names.`)}return e}joinByFaceIndices(t){let e="";const s=[];for(let n=0;n<t.length;n++)s.push(e),s.push(this.facenames[t[n]]),this.prefixFree||(e="_");return s.join("")}spinmatch(t,e){if(t===e)return!0;try{const s=this.splitByFaceNames(t),n=this.splitByFaceNames(e);if(s.length!==n.length&&s.length<3)return!1;for(let i=0;i<s.length;i++){for(let r=0;r<i;r++)if(s[i]===s[r])return!1;let o=!1;for(let r=0;r<n.length;r++)if(s[i]===n[r]){o=!0;break}if(!o)return!1}return!0}catch{return!1}}spinmatchv(t,e){return t.endsWith("v")&&e.endsWith("v")?this.spinmatch(t.slice(0,t.length-1),e.slice(0,e.length-1)):this.spinmatch(t,e)}unswizzle(t){(t.endsWith("v")||t.endsWith("w"))&&t[0]<="Z"&&(t=t.slice(0,t.length-1));const e=t.toUpperCase();for(let s=0;s<this.gripnames.length;s++){const n=this.gripnames[s];if(this.spinmatch(e,n))return n}return t}}class Pt{notationToInternal(t){return t}notationToExternal(t){return t}}class Zt{constructor(t,e){this.child=t,this.sw=e}notationToInternal(t){return t.family==="T"&&t.innerLayer===void 0&&t.outerLayer===void 0?new k(new I("FLRv",t.innerLayer,t.outerLayer),t.amount):this.child.notationToInternal(t)}notationToExternal(t){let e=t.family;return e.length>0&&e[e.length-1]==="v"&&(e=e.substring(0,e.length-1)),this.sw.spinmatch(e,"FLUR")?new k(new I("T",t.innerLayer,t.outerLayer),t.amount):this.child.notationToExternal(t)}}class Mt{constructor(t,e){this.internalNames=t,this.externalNames=e}convertString(t,e,s){let n="";(t.endsWith("v")||t.endsWith("v"))&&t<="_"&&(n=t.slice(t.length-1),t=t.slice(0,t.length-1));const i=t.toUpperCase();let o=!1;return t!==i&&(o=!0,t=i),t=s.joinByFaceIndices(e.splitByFaceNames(t)),o&&(t=t.toLowerCase()),t+n}convert(t,e,s){const n=t.family,i=this.convertString(n,e,s);return n===i?t:new k(new I(i,t.innerLayer,t.outerLayer),t.amount)}notationToInternal(t){return this.convert(t,this.externalNames,this.internalNames)}notationToExternal(t){return this.convert(t,this.internalNames,this.externalNames)}}class Wt{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer===void 0&&t.outerLayer===void 0){if(Math.abs(t.amount)===1){if(t.family==="R++")return new k(new I("L",3,2),-2*t.amount);if(t.family==="R--")return new k(new I("L",3,2),2*t.amount);if(t.family==="D++")return new k(new I("U",3,2),-2*t.amount);if(t.family==="D--")return new k(new I("U",3,2),2*t.amount);if(t.family==="R_PLUSPLUS_")return new k(new I("L",3,2),-2*t.amount);if(t.family==="D_PLUSPLUS_")return new k(new I("U",3,2),-2*t.amount)}if(t.family==="y")return new k("Uv",t.amount);if(t.family==="x"&&Math.abs(t.amount)===2)return new k("ERv",t.amount/2)}return this.child.notationToInternal(t)}notationToExternal(t){return t.family==="ERv"&&Math.abs(t.amount)===1?new k(new I("x",t.innerLayer,t.outerLayer),t.amount*2):t.family==="ILv"&&Math.abs(t.amount)===1?new k(new I("x",t.innerLayer,t.outerLayer),-t.amount*2):t.family==="Uv"?new k(new I("y",t.innerLayer,t.outerLayer),t.amount):t.family==="Dv"?new k("y",-t.amount):this.child.notationToExternal(t)}}class Jt{constructor(t){this.slices=t}notationToInternal(t){const e=t.family;return t.innerLayer||t.outerLayer||(e==="x"?t=new k("Rv",t.amount):e==="y"?t=new k("Uv",t.amount):e==="z"&&(t=new k("Fv",t.amount)),(this.slices&1)===1&&(e==="E"?t=new k(new I("D",(this.slices+1)/2),t.amount):e==="M"?t=new k(new I("L",(this.slices+1)/2),t.amount):e==="S"&&(t=new k(new I("F",(this.slices+1)/2),t.amount))),this.slices>2&&(e==="e"?t=new k(new I("D",this.slices-1,2),t.amount):e==="m"?t=new k(new I("L",this.slices-1,2),t.amount):e==="s"&&(t=new k(new I("F",this.slices-1,2),t.amount)))),t}notationToExternal(t){const e=t.family;if(!(t.innerLayer||t.outerLayer)){if(e==="Rv")return new k("x",t.amount);if(e==="Uv")return new k("y",t.amount);if(e==="Fv")return new k("z",t.amount);if(e==="Lv")return new k("x",-t.amount);if(e==="Dv")return new k("y",-t.amount);if(e==="Bv")return new k("z",-t.amount)}return t}}const Qt={U:"frl",L:"fld",R:"fdr",B:"dlr",u:"FRL",l:"FLD",r:"FDR",b:"DLR",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R"},Yt={U:"FRL",L:"FLD",R:"FDR",B:"DLR",u:"frl",l:"fld",r:"fdr",b:"dlr",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R",d:"d",f:"f",bl:"l",br:"r"},Rt={U:"FRL",L:"FLD",R:"FDR",B:"DLR"},zt=new I("y"),Dt=new I("Dv");class It{constructor(t){this.child=t}wcaHack=!1;map=Qt;notationToInternal(t){if(this.wcaHack&&t.innerLayer===2&&t.outerLayer===null){const s=Rt[t.family];if(s)return new k(new I(s,t.innerLayer,t.outerLayer),t.amount)}const e=this.map[t.family];return e?new k(new I(e,t.innerLayer,t.outerLayer),t.amount):zt.isIdentical(t.quantum)?new k(Dt,-t.amount):null}notationToExternal(t){if(this.wcaHack&&t.innerLayer===2&&t.outerLayer===null){for(const[e,s]of Object.entries(Rt))if(this.child.spinmatch(t.family,s))return new k(new I(e,t.innerLayer,t.outerLayer),t.amount)}for(const[e,s]of Object.entries(this.map))if(this.child.spinmatch(t.family,s))return new k(new I(e,t.innerLayer,t.outerLayer),t.amount);return Dt.isIdentical(t.quantum)?new k(zt,-t.amount):null}}class Vt extends It{wcaHack=!0;constructor(t){super(t),this.map=Yt}}const kt={U:"UBL",UL:"ULF",F:"UFR",UR:"URB",B:"DBL",D:"DFR",L:"DLF",R:"DRB",Uv:"UBLv",ULv:"ULFv",Fv:"UFRv",URv:"URBv",Bv:"DBLv",Dv:"DFRv",Lv:"DLFv",Rv:"DRBv"},gt=new I("x"),Et=new I("Rv"),Xt=new I("Lv"),bt=new I("y"),jt=new I("Uv"),qt=new I("Dv"),wt=new I("z"),Ct=new I("Fv"),_t=new I("Bv");class te{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer||t.outerLayer)return null;const e=kt[t.family];return e?new k(new I(e,t.outerLayer,t.innerLayer),t.amount):gt.isIdentical(t.quantum)?new k(Et,t.amount):bt.isIdentical(t.quantum)?new k(jt,t.amount):wt.isIdentical(t.quantum)?new k(Ct,t.amount):null}notationToExternal(t){for(const[e,s]of Object.entries(kt))if(this.child.spinmatchv(t.family,s))return new k(new I(e,t.innerLayer,t.outerLayer),t.amount);return Et.isIdentical(t.quantum)?new k(gt,t.amount):Xt.isIdentical(t.quantum)?new k(gt,-t.amount):jt.isIdentical(t.quantum)?new k(bt,t.amount):qt.isIdentical(t.quantum)?new k(bt,-t.amount):Ct.isIdentical(t.quantum)?new k(wt,t.amount):_t.isIdentical(t.quantum)?new k(wt,-t.amount):null}}function ee(h,t){const e={...h,moves:{}};for(const[s,n]of Object.entries(h.moves)){let i=s,o="";["v","w"].includes(s.at(-1))&&(i=s.slice(0,-1),o=s.slice(-1));const r=t.notationToExternal(k.fromString(i));if(!r)continue;const b=r+o;if(!b)throw new Error(`Missing external move name for: ${s.toString()}`);e.moves[b.toString()]=n}return e}function ze(h){let t=0;const e={};for(;t<h.length&&h[t][0]==="-";){const n=h[t++];if(n==="--rotations")e.addRotations=!0;else if(n==="--allmoves")e.allMoves=!0;else if(n==="--outerblockmoves")e.outerBlockMoves=!0;else if(n==="--vertexmoves")e.vertexMoves=!0;else if(n==="--nocorners")e.includeCornerOrbits=!1;else if(n==="--noedges")e.includeEdgeOrbits=!1;else if(n==="--noorientation")e.fixedOrientation=!0;else if(n==="--nocenters")e.includeCenterOrbits=!1;else if(n==="--omit")e.excludeOrbits=h[t].split(","),t++;else if(n==="--moves")e.moveList=h[t].split(","),t++;else if(n==="--optimize")e.optimizeOrbits=!0;else if(n==="--scramble")e.scrambleAmount=100;else if(n==="--fixcorner")e.fixedPieceType="v";else if(n==="--fixedge")e.fixedPieceType="e";else if(n==="--fixcenter")e.fixedPieceType="f";else if(n==="--orientcenters")e.orientCenters=!0;else if(n==="--puzzleorientation")e.puzzleOrientation=JSON.parse(h[t]),t++;else throw new Error(`Bad option: ${n}`)}return{puzzleDescription:At(h.slice(t).join(" ")),options:e}}class se{verbosity=0;allMoves=!1;outerBlockMoves;vertexMoves=!1;addRotations=!1;moveList=null;fixedOrientation=!1;fixedPieceType=null;orientCenters=!1;includeCornerOrbits=!0;includeCenterOrbits=!0;includeEdgeOrbits=!0;excludeOrbits=[];optimizeOrbits=!1;grayCorners=!1;grayCenters=!1;grayEdges=!1;puzzleOrientation=null;puzzleOrientations=null;scrambleAmount=0;constructor(t={}){Object.assign(this,t)}}const vt=[],yt=[];function it(h){if(!vt[h]){const t=Array(h);for(let e=0;e<h;e++)t[e]=0;vt[h]=t}return vt[h]}function st(h){if(!yt[h]){const t=Array(h);for(let e=0;e<h;e++)t[e]=e;yt[h]=t}return yt[h]}function ne(h){return new _(st(h))}function ie(h){let t=BigInt(1);for(;h>1;)t*=BigInt(h),h--;return t}function oe(h,t){if(h>t){const e=h;h=t,t=e}for(;h>0;){const e=t%h;t=h,h=e}return t}function Nt(h,t){return h/oe(h,t)*t}class _{n;p;constructor(t){this.n=t.length,this.p=t}toString(){return`Perm[${this.p.join(" ")}]`}mul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=t.p[this.p[s]];return new _(e)}rmul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=this.p[t.p[s]];return new _(e)}inv(){const t=Array(this.n);for(let e=0;e<this.n;e++)t[this.p[e]]=e;return new _(t)}compareTo(t){for(let e=0;e<this.n;e++)if(this.p[e]!==t.p[e])return this.p[e]-t.p[e];return 0}toGap(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const n=new Array;for(let i=this.p[s];!e[i];i=this.p[i])n.push(1+i),e[i]=!0;t.push(`(${n.reverse().join(",")})`)}return t.join("")}toMathematica(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const n=new Array;for(let i=this.p[s];!e[i];i=this.p[i])n.push(1+i),e[i]=!0;t.push(`{${n.reverse().join(",")}}`)}return`Cycles[{${t.join(",")}}]`}order(){let t=1;const e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;let n=0;for(let i=s;!e[i];i=this.p[i])n++,e[i]=!0;t=Nt(t,n)}return t}}class Bt{constructor(t,e){this.size=t,this.mod=e}reassemblySize(){return ie(this.size)*BigInt(this.mod)**BigInt(this.size)}}let re=0;function ct(h,t){const e=k.fromString(t),s=h.notationToExternal(e);return s===null||e===s?t:s.toString()}class mt{constructor(t,e,s,n,i,o,r){this.orbitnames=t,this.orbitdefs=e,this.solved=s,this.movenames=n,this.moveops=i,this.isRotation=o,this.forcenames=r}toKTransformationData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKTransformationOrbitData();return e}toKPatternData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKPatternOrbitData();return e}static transformToKTransformationData(t,e){const s={};for(let n=0;n<t.length;n++)s[t[n]]=e.orbits[n].toKTransformationOrbitData();return s}describeSet(t,e,s){const n=this.orbitdefs[t].size,i=new Array(n);for(let o=0;o<n;o++)i[o]=[];for(let o=0;o<this.movenames.length;o++){if(this.isRotation[o])continue;let r=this.movenames[o];this.forcenames[o]||(r=ct(s,r),r[r.length-1]==="'"&&(r=r.substring(0,r.length-1)));const b=this.moveops[o].orbits[t];for(let l=0;l<n;l++)(b.perm[l]!==l||b.ori[l]!==0)&&i[l].push(r)}for(let o=0;o<n;o++)e.push(`# ${o+1} ${i[o].join(" ")}`)}toKsolve(t,e=new Pt){const s=[];s.push(`Name ${t}`),s.push("");for(let n=0;n<this.orbitnames.length;n++)s.push(`Set ${this.orbitnames[n]} ${this.orbitdefs[n].size} ${this.orbitdefs[n].mod}`),this.describeSet(n,s,e);s.push(""),s.push("Solved");for(let n=0;n<this.orbitnames.length;n++)this.solved.orbits[n].appendDefinition(s,this.orbitnames[n],!1,!1);s.push("End");for(let n=0;n<this.movenames.length;n++){s.push("");let i=this.movenames[n];this.forcenames[n]||(i=ct(e,this.movenames[n]));let o=!1;i[i.length-1]==="'"&&(o=!0,i=i.substring(0,i.length-1)),s.push(`Move ${i}`);for(let r=0;r<this.orbitnames.length;r++)o?this.moveops[n].orbits[r].inv().appendDefinition(s,this.orbitnames[r],!0):this.moveops[n].orbits[r].appendDefinition(s,this.orbitnames[r],!0);s.push("End")}return s}toKPuzzleDefinition(t){const e=[],s={};for(let i=0;i<this.orbitnames.length;i++){e.push({orbitName:this.orbitnames[i],numPieces:this.orbitdefs[i].size,numOrientations:this.orbitdefs[i].mod});const o=this.solved.orbits[i].toKTransformationOrbitData();s[this.orbitnames[i]]={pieces:o.permutation,orientation:o.orientationDelta}}const n={};if(t)for(let i=0;i<this.movenames.length;i++)n[this.movenames[i]]=this.toKTransformationData(this.moveops[i]);return{name:`PG3D #${++re}`,orbits:e,defaultPattern:s,moves:n}}optimize(){const t=[],e=[],s=[],n=[];for(let i=0;i<this.moveops.length;i++)n.push([]);for(let i=0;i<this.orbitdefs.length;i++){const o=this.orbitdefs[i].mod,r=this.orbitdefs[i].size,b=new Ut(r),l=new Array(this.orbitdefs[i].size);for(let f=0;f<r;f++)l[f]=!1;for(let f=0;f<this.moveops.length;f++)for(let p=0;p<r;p++)(this.moveops[f].orbits[i].perm[p]!==p||this.moveops[f].orbits[i].ori[p]!==0)&&(this.isRotation[f]||(l[p]=!0),b.union(p,this.moveops[f].orbits[i].perm[p]));let u=!0;if(o>1){u=!1;const f=new Ut(this.orbitdefs[i].size*o);for(let p=0;p<this.moveops.length;p++)for(let a=0;a<r;a++)if(this.moveops[p].orbits[i].perm[a]!==a||this.moveops[p].orbits[i].ori[a]!==0)for(let d=0;d<o;d++)f.union(a*o+d,this.moveops[p].orbits[i].perm[a]*o+(d+this.moveops[p].orbits[i].ori[a])%o);for(let p=0;!u&&p<r;p++)for(let a=1;a<o;a++)f.find(p*o)===f.find(p*o+a)&&(u=!0);for(let p=0;!u&&p<r;p++)for(let a=0;a<p;a++)this.solved.orbits[i].perm[p]===this.solved.orbits[i].perm[a]&&(u=!0)}let w=-1,g=!1;for(let f=0;f<this.orbitdefs[i].size;f++)if(l[f]){const p=b.find(f);w<0?w=p:w!==p&&(g=!0)}for(let f=0;f<this.orbitdefs[i].size;f++){if(!l[f]||b.find(f)!==f)continue;const a=[],d=[];let B=0;for(let v=0;v<this.orbitdefs[i].size;v++)b.find(v)===f&&(a[B]=v,d[v]=B,B++);if(g?t.push(`${this.orbitnames[i]}_p${f}`):t.push(this.orbitnames[i]),u){e.push(new Bt(B,this.orbitdefs[i].mod)),s.push(this.solved.orbits[i].remapVS(a,B));for(let v=0;v<this.moveops.length;v++)n[v].push(this.moveops[v].orbits[i].remap(a,d,B))}else{e.push(new Bt(B,1)),s.push(this.solved.orbits[i].remapVS(a,B).killOri());for(let v=0;v<this.moveops.length;v++)n[v].push(this.moveops[v].orbits[i].remap(a,d,B).killOri())}}}return new mt(t,e,new pt(s),this.movenames,n.map(i=>new ot(i)),this.isRotation,this.forcenames)}scramble(t){this.solved=this.solved.mul(this.getScrambleTransformation(t))}getScrambleTransformation(t){t<100&&(t=100);const e=[];for(let n=0;n<this.moveops.length;n++)e[n]=this.moveops[n];for(let n=0;n<e.length;n++){const i=Math.floor(Math.random()*e.length),o=e[n];e[n]=e[i],e[i]=o}t<e.length&&(t=e.length);for(let n=0;n<t;n++){const i=Math.floor(Math.random()*e.length),o=Math.floor(Math.random()*e.length),r=Math.floor(Math.random()*this.moveops.length);e[i]=e[i].mul(e[o]).mul(this.moveops[r]),Math.random()<.1&&(e[i]=e[i].mul(this.moveops[r]))}let s=e[0];for(let n=1;n<e.length;n++)s=s.mul(e[n]);return s}reassemblySize(){let t=BigInt(1);for(let e=0;e<this.orbitdefs.length;e++)t*=this.orbitdefs[e].reassemblySize();return t}}class J{constructor(t,e,s){this.perm=t,this.ori=e,this.orimod=s}static ktransformationCache=[];static e(t,e){return new J(st(t),it(t),e)}mul(t){const e=this.perm.length,s=new Array(e);if(this.orimod===1){for(let n=0;n<e;n++)s[n]=this.perm[t.perm[n]];return new J(s,this.ori,this.orimod)}else{const n=new Array(e);for(let i=0;i<e;i++)s[i]=this.perm[t.perm[i]],n[i]=(this.ori[t.perm[i]]+t.ori[i])%this.orimod;return new J(s,n,this.orimod)}}inv(){const t=this.perm.length,e=new Array(t),s=new Array(t);for(let n=0;n<t;n++)e[this.perm[n]]=n,s[this.perm[n]]=(this.orimod-this.ori[n])%this.orimod;return new J(e,s,this.orimod)}equal(t){const e=this.perm.length;for(let s=0;s<e;s++)if(this.perm[s]!==t.perm[s]||this.ori[s]!==t.ori[s])return!1;return!0}killOri(){const t=this.perm.length;for(let e=0;e<t;e++)this.ori[e]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(t===1)return new _(this.perm);const e=this.perm.length,s=new Array(e*t);for(let n=0;n<e;n++)for(let i=0;i<t;i++)s[n*t+i]=t*this.perm[n]+(this.ori[n]+i)%t;return new _(s)}identicalPieces(){const t=[],e=this.perm.length,s=[];for(let n=0;n<e;n++){const i=this.perm[n];if(t[i]===void 0){const o=[n];t[i]=!0;for(let r=n+1;r<e;r++)this.perm[r]===i&&o.push(r);s.push(o)}}return s}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;if(this.perm===st(t)&&this.ori===it(t))return!0;for(let e=0;e<t;e++)if(this.perm[e]!==e||this.ori[e]!==0)return!1;return!0}zeroOris(){const t=this.perm.length;if(this.ori===it(t))return!0;for(let e=0;e<t;e++)if(this.ori[e]!==0)return!1;return!0}remap(t,e,s){const n=new Array(s),i=new Array(s);for(let o=0;o<s;o++)n[o]=e[this.perm[t[o]]],i[o]=this.ori[t[o]];return new J(n,i,this.orimod)}remapVS(t,e){const s=new Array(e),n=new Array(e);let i=0;const o=[];for(let r=0;r<e;r++){const b=this.perm[t[r]];o[b]===void 0&&(o[b]=i++),s[r]=o[b],n[r]=this.ori[t[r]]}return new J(s,n,this.orimod)}appendDefinition(t,e,s,n=!0){if(!(n&&this.isIdentity())&&(t.push(e),t.push(this.perm.map(i=>i+1).join(" ")),!this.zeroOris()))if(s){const i=new Array(this.ori.length);for(let o=0;o<i.length;o++)i[this.perm[o]]=this.ori[o];t.push(i.join(" "))}else t.push(this.ori.join(" "))}toKTransformationOrbitData(){const t=this.perm.length;return this.isIdentity()?(J.ktransformationCache[t]||(J.ktransformationCache[t]={permutation:st(t),orientationDelta:it(t)}),J.ktransformationCache[t]):{permutation:this.perm,orientationDelta:this.ori}}toKPatternOrbitData(){const t=this.perm.length;return{pieces:this.perm,orientation:this.ori,orientationMod:it(t)}}}class St{constructor(t){this.orbits=t}internalMul(t){const e=[];for(let s=0;s<this.orbits.length;s++)e.push(this.orbits[s].mul(t.orbits[s]));return e}internalInv(){const t=[];for(const e of this.orbits)t.push(e.inv());return t}equal(t){for(let e=0;e<this.orbits.length;e++)if(!this.orbits[e].equal(t.orbits[e]))return!1;return!0}killOri(){for(const t of this.orbits)t.killOri();return this}toPerm(){const t=new Array;let e=0;for(const n of this.orbits){const i=n.toPerm();t.push(i),e+=i.n}const s=new Array(e);e=0;for(const n of t){for(let i=0;i<n.n;i++)s[e+i]=e+n.p[i];e+=n.n}return new _(s)}identicalPieces(){const t=[];let e=0;for(const s of this.orbits){const n=s.orimod,i=s.identicalPieces();for(let o=0;o<i.length;o++)t.push(i[o].map(r=>r*n+e));e+=n*s.perm.length}return t}order(){let t=1;for(const e of this.orbits)t=Nt(t,e.order());return t}}class ot extends St{mul(t){return new ot(this.internalMul(t))}mulScalar(t){if(t===0)return this.e();let e=this;for(t<0&&(e=e.inv(),t=-t);!(t&1);)e=e.mul(e),t>>=1;if(t===1)return e;let s=e,n=this.e();for(;t>0;)t&1&&(n=n.mul(s)),t>1&&(s=s.mul(s)),t>>=1;return n}inv(){return new ot(this.internalInv())}e(){return new ot(this.orbits.map(t=>J.e(t.perm.length,t.orimod)))}}class pt extends St{mul(t){return new pt(this.internalMul(t))}}class Ut{constructor(t){this.n=t,this.heads=new Array(t);for(let e=0;e<t;e++)this.heads[e]=e}heads;find(t){let e=this.heads[t];return this.heads[e]===e||(e=this.find(this.heads[e]),this.heads[t]=e),e}union(t,e){const s=this.find(t),n=this.find(e);s<n?this.heads[n]=s:s>n&&(this.heads[s]=n)}}function ae(h,t){const e=h.moveops.length;if(e>30)throw new Error("Canon info too big for bitmask");const s=[],n=[];for(let o=0;o<e;o++){const r=h.moveops[o];s.push(r.order());let b=0;for(let l=0;l<e;l++){if(l===o)continue;const u=h.moveops[l];r.mul(u).equal(u.mul(r))&&(b|=1<<l)}n.push(b)}let i={};i[0]=1;for(let o=0;o<100;o++){let r=0;const b={};let l=0;for(const u in i){const w=+u,g=i[w];r+=g,l++;for(let f=0;f<s.length;f++)if(!(w>>f&1)&&!(w&n[f]&(1<<f)-1)){const p=w&n[f]|1<<f;b[p]===void 0&&(b[p]=0),b[p]+=(s[f]-1)*g}}t(`${o}: canonseq ${r} states ${l}`),i=b}}const Ft={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333","40x40x40":"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547","curvy copter":"c e 0.83",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667",tetraminx:"t v 0.333333333333333","master pyraminx":"t v 0 v 1 v 2","master tetraminx":"t v 0 v 1","professor pyraminx":"t v -0.2 v 0.6 v 1.4 v 2.2","professor tetraminx":"t v -0.2 v 0.6 v 1.4","royal pyraminx":"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667 v 2.33333333333333","royal tetraminx":"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667","emperor pyraminx":"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286 v 2.42857142857143","emperor tetraminx":"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286","Jing pyraminx":"t f 0","master pyramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",teraminx:"d f 0.64 f 0.76 f 0.88",petaminx:"d f 0.64 f 0.73 f 0.82 f 0.91",examinx:"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",zetaminx:"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",yottaminx:"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",pentultimate:"d f 0","master pentultimate":"d f 0.1","elite pentultimate":"d f 0 f 0.145905",starminx:"d v 0.937962370425399","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","master FTO":"o f 0.5 f 0","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","Regular Astrominx":"i v 0.18759247376021","Regular Astrominx + Big Chop":"i v 0.18759247376021 e 0",Redicosahedron:"i v 0.794654472291766","Redicosahedron with centers":"i v 0.84",Icosaminx:"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.937962370425399"},nt=1e-9;function xt(h){let t=new $(0,0,0,0);for(let e=0;e<h.length;e++)t=t.sum(h[e]);return t.smul(1/h.length)}function le(h,t,e,s){const n=s[h].intersect3(s[t],s[e]);if(!n)return n;for(let i=0;i<s.length;i++)if(i!==h&&i!==t&&i!==e){const o=s[i].b*n.b+s[i].c*n.c+s[i].d*n.d;if(s[i].a>0&&o>s[i].a||s[i].a<0&&o<s[i].a)return!1}return n}class ${constructor(t,e,s,n){this.a=t,this.b=e,this.c=s,this.d=n}mul(t){return new $(this.a*t.a-this.b*t.b-this.c*t.c-this.d*t.d,this.a*t.b+this.b*t.a+this.c*t.d-this.d*t.c,this.a*t.c-this.b*t.d+this.c*t.a+this.d*t.b,this.a*t.d+this.b*t.c-this.c*t.b+this.d*t.a)}toString(){return`Q[${this.a},${this.b},${this.c},${this.d}]`}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(t){return new $(0,this.c*t.d-this.d*t.c,this.d*t.b-this.b*t.d,this.b*t.c-this.c*t.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const t=Math.sqrt(this.dot(this));return new $(this.a/t,this.b/t,this.c/t,this.d/t)}makenormal(){return new $(0,this.b,this.c,this.d).normalize()}normalizeplane(){const t=Math.hypot(this.b,this.c,this.d);return new $(this.a/t,this.b/t,this.c/t,this.d/t)}smul(t){return new $(this.a*t,this.b*t,this.c*t,this.d*t)}sum(t){return new $(this.a+t.a,this.b+t.b,this.c+t.c,this.d+t.d)}sub(t){return new $(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new $(this.a,-this.b,-this.c,-this.d)}det3x3(t,e,s,n,i,o,r,b,l){return t*(i*l-o*b)+e*(o*r-n*l)+s*(n*b-i*r)}rotateplane(t){const e=t.mul(new $(0,this.b,this.c,this.d)).mul(t.invrot());return e.a=this.a,e}orthogonal(){const t=Math.abs(this.b),e=Math.abs(this.c),s=Math.abs(this.d);return t<e&&t<s?this.cross(new $(0,1,0,0)).normalize():e<t&&e<s?this.cross(new $(0,0,1,0)).normalize():this.cross(new $(0,0,0,1)).normalize()}pointrotation(t){const e=this.normalize();if(t=t.normalize(),e.sub(t).len()<nt)return new $(1,0,0,0);let s=e.sum(t);s.len()<nt?s=s.orthogonal():s=s.normalize();const n=e.cross(s);return n.a=e.dot(s),n}unproject(t){return this.sum(t.smul(-this.dot(t)/(this.len()*t.len())))}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){return t.map(e=>e.rotatepoint(this))}intersect3(t,e){const s=this.det3x3(this.b,this.c,this.d,t.b,t.c,t.d,e.b,e.c,e.d);return Math.abs(s)<nt?!1:new $(0,this.det3x3(this.a,this.c,this.d,t.a,t.c,t.d,e.a,e.c,e.d)/s,this.det3x3(this.b,this.a,this.d,t.b,t.a,t.d,e.b,e.a,e.d)/s,this.det3x3(this.b,this.c,this.a,t.b,t.c,t.a,e.b,e.c,e.a)/s)}side(t){return t>nt?1:t<-nt?-1:0}cutface(t){const e=this.a;let s=0,n=null;for(let i=0;i<t.length;i++)s|=1<<this.side(t[i].dot(this)-e)+1;if((s&5)===5){n=[];const i=t.map(o=>this.side(o.dot(this)-e));for(let o=-1;o<=1;o+=2){const r=[];for(let b=0;b<t.length;b++){(i[b]===o||i[b]===0)&&r.push(t[b]);const l=(b+1)%t.length;if(i[b]+i[l]===0&&i[b]!==0){const u=t[b].dot(this)-e,w=t[l].dot(this)-e,g=u/(u-w),f=t[b].smul(1-g).sum(t[l].smul(g));r.push(f)}}n.push(r)}}return n}cutfaces(t){const e=[];for(let s=0;s<t.length;s++){const n=t[s],i=this.cutface(n);i?(e.push(i[0]),e.push(i[1])):e.push(n)}return e}faceside(t){const e=this.a;for(let s=0;s<t.length;s++){const n=this.side(t[s].dot(this)-e);if(n!==0)return n}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const e=this.normalize(),s=t.normalize();return e.dist(s)<nt||e.dist(s.smul(-1))<nt}makecut(t){return new $(t,this.b,this.c,this.d)}}const ft=1e-9;function he(){const h=Math.sqrt(.5);return[new $(h,h,0,0),new $(h,0,h,0)]}function ce(){return[new $(.5,.5,.5,.5),new $(.5,.5,.5,-.5)]}function fe(){const h=2*Math.PI/10;let t=.5+.3*Math.sqrt(5),e=.5+.1*Math.sqrt(5);const s=Math.sqrt(t*t+e*e);return t/=s,e/=s,[new $(Math.cos(h),t*Math.sin(h),e*Math.sin(h),0),new $(.5,.5,.5,.5)]}function ue(){let h=.16666666666666666+Math.sqrt(5)/6,t=2/3+Math.sqrt(5)/3;const e=Math.sqrt(h*h+t*t);h/=e,t/=e;const s=2*Math.PI/6;return[new $(Math.cos(s),h*Math.sin(s),t*Math.sin(s),0),new $(Math.cos(s),-h*Math.sin(s),t*Math.sin(s),0)]}function me(){const h=Math.sqrt(.5);return[new $(.5,.5,.5,.5),new $(h,0,0,h)]}function pe(h){const t=[new $(1,0,0,0)];for(let e=0;e<t.length;e++)for(let s=0;s<h.length;s++){const n=h[s].mul(t[e]),i=n.smul(-1);let o=!1;for(let r=0;r<t.length;r++)if(n.dist(t[r])<ft||i.dist(t[r])<ft){o=!0;break}o||t.push(n)}return t}function $t(h,t){const e=[],s=[];for(let n=0;n<t.length;n++){const i=h.rotateplane(t[n]);let o=!1;for(let r=0;r<e.length;r++)if(i.dist(e[r])<ft){o=!0;break}o||(e.push(i),s.push(t[n]))}return s}function Ot(h){const t=[];for(let e=1;e<h.length;e++)for(let s=e+1;s<h.length;s++){const n=le(0,e,s,h);if(n){let i=!1;for(let o=0;o<t.length;o++)if(n.dist(t[o])<ft){i=!0;break}i||t.push(n)}}for(;;){let e=!1;for(let s=0;s<t.length;s++){const n=(s+1)%t.length;if(h[0].dot(t[s].cross(t[n]))<0){const i=t[s];t[s]=t[n],t[n]=i,e=!0}}if(!e)break}return t}class de{mult;constructor(){this.mult=[]}multiply(t){for(let e=2;e*e<=t;e++)for(;t%e===0;)this.mult[e]!==void 0?this.mult[e]++:this.mult[e]=1,t/=e;t>1&&(this.mult[t]!==void 0?this.mult[t]++:this.mult[t]=1)}toString(){let t="";for(let e=0;e<this.mult.length;e++)this.mult[e]!==void 0&&(t!==""&&(t+="*"),t+=e,this.mult[e]>1&&(t+=`^${this.mult[e]}`));return t}}function ge(h,t){const e=h[0].p.length,s=ne(e);let n=[],i=[],o=[],r=[],b=[];function l(f){for(let p=f.p.length-1;p>=0;p--){const a=f.p[p];if(a!==p){if(!n[p][a])return!1;f=f.mul(i[p][a])}}return!0}function u(f,p,a){r[f].push(p),b[f].push(a);for(let d=0;d<n[f].length;d++)n[f][d]&&w(f,n[f][d].mul(p),a+o[f][d])}function w(f,p,a){const d=p.p[f];if(!n[f][d]){n[f][d]=p,i[f][d]=p.inv(),o[f][d]=a;for(let v=0;v<r[f].length;v++)w(f,p.mul(r[f][v]),a+b[f][v]);return}const B=p.mul(i[f][d]);l(B)||u(f-1,B,a+o[f][d])}function g(){n=[],i=[],r=[],o=[],b=[];for(let a=0;a<e;a++)n.push([]),i.push([]),o.push([]),r.push([]),b.push([]),n[a][a]=s,i[a][a]=s,o[a][a]=0;let f=0,p=BigInt(1);for(let a=0;a<h.length;a++){u(e-1,h[a],1),p=BigInt(1);let d=0,B=0;const v=new de;for(let y=0;y<e;y++){let M=0,z=0;for(let G=0;G<e;G++)n[y][G]&&(M++,z+=o[y][G],y!==G&&f++);d+=r[y].length,p*=BigInt(M),M>1&&v.multiply(M);const N=z/M;B+=N}t(`${a}: sz ${p} T ${d} sol ${B} none ${f} mults ${v.toString()}`)}return p}return g()}class rt{coords;length;constructor(t){this.coords=new Array(t.length*3);for(let e=0;e<t.length;e++)this.coords[3*e]=t[e].b,this.coords[3*e+1]=t[e].c,this.coords[3*e+2]=t[e].d;this.length=t.length}get(t){return new $(0,this.coords[3*t],this.coords[3*t+1],this.coords[3*t+2])}centermass(){let t=0,e=0,s=0;for(let n=0;n<this.length;n++)t+=this.coords[3*n],e+=this.coords[3*n+1],s+=this.coords[3*n+2];return new $(0,t/this.length,e/this.length,s/this.length)}rotate(t){const e=[];for(let s=0;s<this.length;s++)e.push(this.get(s).rotatepoint(t));return new rt(e)}rotateforward(){const t=[];for(let e=1;e<this.length;e++)t.push(this.get(e));return t.push(this.get(0)),new rt(t)}}class ut{constructor(t,e,s){this.face=t,this.left=e,this.right=s}split(t){const e=t.cutface(this.face);return e!==null&&(this.left===void 0?(this.left=new ut(e[0]),this.right=new ut(e[1])):(this.left=this.left?.split(t),this.right=this.right?.split(t))),this}collect(t,e){return this.left===void 0?t.push(new rt(this.face)):e?(this.left?.collect(t,!1),this.right?.collect(t,!0)):(this.right?.collect(t,!1),this.left?.collect(t,!0)),t}}function be(h,t){const e=[];for(const s of h)for(const n of t)e.push(n.rotate(s));return e}const H=1e-9,we="PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.";function ve(){return{4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","BR",""],["BR","D","","BB"],["BB","BR","U","BL"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]}}const ye={4:{v:["DFR","DLF","DRL","FLR"],e:["FR","LF","DF","DL","RD","RL"],c:["DF","FD","RL","LR"]},6:{v:["URF","UBR","ULB","UFL","DFR","DRB","DBL","DLF"],e:["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],c:["UB","LU","FU","RU","BU","DF"]},8:{v:["UBBBRR","URFL","ULBLBB","DBRBBBL","DBLLF","DFRBR"],e:["UL","UBB","UR","BRD","BLD","FD","BRR","FR","FL","BLL","BLBB","BRBB"],c:["BBU","LU","RU","BRD","FD","BLD","DF","UBB"]},12:{v:["URF","UFL","ULBL","UBLBR","UBRR","DEBF","DBFI","DIA","DAC","DCE","LAI","ALF","FCA","CFR","REC","ERBR","BRBFE","BFBRBL","BLIBF","IBLL"],e:["UF","UR","UBR","UBL","UL","ER","EBR","EBF","ED","EC","IBF","IBL","IL","IA","ID","AC","CF","FA","BFBR","BRBL","BLBF","CD","AD","AL","FL","FR","CR","BFD","BRR","BLL"],c:["UF","FU","DBF","BFD","AD","CD","BRU","BLU","LA","RA","EBR","IBL"]},20:{v:["FLPQU","FUGER","FRCAL","HCREI","ISBDH","JSIEG","BSJMK","MQPOK","ONDBK","NOPLA","UQMJG","DNACH"],e:["FU","FL","FR","EG","ER","EI","SJ","SI","SB","KM","KB","KO","PQ","PO","PL","UG","JG","MQ","UQ","HC","HD","ND","NA","JM","CA","AL","CR","HI","DB","NO"],c:["FU","UF","GE","EG","JS","SJ","MK","KM","QP","PQ","LA","AL","RC","CR","IH","HI","BD","DB","ON","NO"]}};function xe(){return{4:[["FLR",[0,1,0]],["F",[0,0,1]]],6:[["U",[0,1,0]],["F",[0,0,1]]],8:[["U",[0,1,0]],["F",[0,0,1]]],12:[["U",[0,1,0]],["F",[0,0,1]]],20:[["GUQMJ",[0,1,0]],["F",[0,0,1]]]}}function lt(h,t){for(let e=0;e<h.length;e++)if(h[e][0].dist(t)<H)return e;throw new Error("Element not found")}function De(){return Ft}function ke(h){return Ft[h]}const Ee=["c","t","o","d","i"],je=["f","v","e"];function At(h){const t=h.split(/ /).filter(Boolean);if(t.length%2===0)return null;const e=t[0];if(e!=="o"&&e!=="c"&&e!=="i"&&e!=="d"&&e!=="t")return null;const s=[];for(let n=1;n<t.length;n+=2){if(t[n]!=="f"&&t[n]!=="v"&&t[n]!=="e")return null;s.push({cutType:t[n],distance:parseFloat(t[n+1])})}return{shape:e,cuts:s}}function Le(h,t={}){const e=At(h);if(e===null)throw new Error("Could not parse the puzzle description");const s=new Me(e,Object.assign({},{allMoves:!0},t));return s.allstickers(),s.genperms(),s}function Ce(h,t){return Le(Ft[h],t)}function Be(h,t,e){let s=!1;e-t[1]<t[0]&&(h=[h[2],h[3],h[0],h[1]],t=[e-t[1],e-t[0]],s=!0);let n=h[0],i="";if(t[0]===0&&t[1]===e)n=`${n}v`;else if(t[0]===t[1])t[1]>0&&(i=String(t[1]+1));else if(t[0]===0)n=n.toLowerCase(),t[1]>1&&(i=String(t[1]+1));else throw new Error(`We only support slice and outer block moves right now. ${t}`);return[i+n,s]}function Fe(h,t){const e=[];let s=0;for(;s<h.length;){s>0&&s<h.length&&h[s]==="_"&&s++;let n="";for(const i of t)h.substr(s).startsWith(i[1])&&i[1].length>n.length&&(n=i[1]);if(n!=="")e.push(n),s+=n.length;else throw new Error(`Could not split ${h} into face names.`)}return e}function ht(h,t){return[h.b/t,-h.c/t,h.d/t]}function Lt(h,t){const e=[],s=h.length;for(let n=0;n<s;n++){const i=ht(h.get(s-n-1),t);e[3*n]=i[0],e[3*n+1]=i[1],e[3*n+2]=i[2]}return e}class Me{constructor(t,e){this.puzzleDescription=t,this.options=new se(e),this.options.verbosity>0&&console.log(this.header("# ")),this.create(t)}rotations;baseplanerot;baseplanes;facenames;faceplanes;edgenames;vertexnames;geonormals;moveplanes;moveplanes2;moveplanesets;moveplanenormals;movesetorders;movesetgeos;basefaces;faces;facecentermass;baseFaceCount;stickersperface;shortedge;markedface;cubies;vertexdistance;edgedistance;facetocubie;facetoord;moverotations;facelisthash;cubiesetnames;cubieords;cubiesetnums;cubieordnums;orbitoris;cubievaluemap;cubiesetcubies;cmovesbyslice=[];parsedmovelist;duplicatedFaces=[];duplicatedCubies=[];fixedCubie=-1;net=[];colors=[];swizzler;notationMapper=new Pt;addNotationMapper="";setReidOrder=!1;options;create(t){const{shape:e,cuts:s}=t;this.moveplanes=[],this.moveplanes2=[],this.faces=[],this.cubies=[];let n=null;switch(e){case"c":{n=he();break}case"o":{n=me();break}case"i":{n=ue();break}case"t":{n=ce();break}case"d":{n=fe();break}default:throw new Error(`Bad shape argument: ${e}`)}this.rotations=pe(n),this.options.verbosity&&console.log(`# Rotations: ${this.rotations.length}`);const i=n[0];this.baseplanerot=$t(i,this.rotations);const o=this.baseplanerot.map(c=>i.rotateplane(c));this.baseplanes=o,this.baseFaceCount=o.length;const r=ve()[o.length];this.net=r,this.colors=Ht()[o.length],this.options.verbosity>0&&console.log(`# Base planes: ${o.length}`);const b=Ot(o),l=new $(0,0,0,0);this.options.verbosity>0&&console.log(`# Face vertices: ${b.length}`);const u=o[0].makenormal(),w=b[0].sum(b[1]).makenormal(),g=b[0].makenormal(),f=new $(1,u.b,u.c,u.d);this.options.verbosity>0&&console.log(`# Boundary is ${f}`);const a=$t(f,this.rotations).map(c=>f.rotateplane(c)),d=Ot(a);this.edgedistance=d[0].sum(d[1]).smul(.5).dist(l),this.vertexdistance=d[0].dist(l);const B=[],v=[];let y=!1,M=!1,z=!1;for(const c of s){let x=null,C=0;switch(c.cutType){case"f":{x=u,C=1,y=!0;break}case"v":{x=g,C=this.vertexdistance,z=!0;break}case"e":{x=w,C=this.edgedistance,M=!0;break}default:throw new Error(`Bad cut argument: ${c.cutType}`)}B.push(x.makecut(c.distance)),v.push(c.distance<C)}this.options.addRotations&&(y||B.push(u.makecut(10)),z||B.push(g.makecut(10)),M||B.push(w.makecut(10))),this.basefaces=[];for(const c of this.baseplanerot){const x=c.rotateface(d);this.basefaces.push(new rt(x))}const N=[],G=[],T=[],m=[],F=d.length;function U(c,x,C){for(const D of c)if(D[0].dist(x)<H){D.push(C);return}c.push([x,C])}for(let c=0;c<this.baseplanerot.length;c++){const x=this.baseplanerot[c].rotateface(d);for(let C=0;C<x.length;C++){const D=(C+1)%x.length,P=x[C].sum(x[D]).smul(.5);U(m,P,c)}}const E=[];for(let c=0;c<this.baseplanerot.length;c++){const x=this.baseplanerot[c].rotateface(d),C=[];for(let D=0;D<x.length;D++){const P=(D+1)%x.length,A=x[D].sum(x[P]).smul(.5),W=m[lt(m,A)];if(c===W[1])C.push(W[2]);else if(c===W[2])C.push(W[1]);else throw new Error("Could not find edge")}E.push(C)}const L={},R=[];R.push(r[0][0]),L[r[0][0]]=0,R[E[0][0]]=r[0][1],L[r[0][1]]=E[0][0];for(const c of r){const x=c[0],C=L[x];if(C===void 0)throw new Error("Bad edge description; first edge not connected");let D=-1;for(let P=0;P<E[C].length;P++){const A=R[E[C][P]];if(A!==void 0&&A===c[1]){D=P;break}}if(D<0)throw new Error("First element of a net not known");for(let P=2;P<c.length;P++){if(c[P]==="")continue;const A=E[C][(P+D-1)%F],W=R[A];if(W!==void 0&&W!==c[P])throw new Error("Face mismatch in net");R[A]=c[P],L[c[P]]=A}}for(let c=0;c<this.baseplanerot.length;c++){const x=this.baseplanerot[c].rotateface(d),C=f.rotateplane(this.baseplanerot[c]),D=R[c];N.push([x,D]),G.push([C,D])}for(let c=0;c<this.baseplanerot.length;c++){const x=this.baseplanerot[c].rotateface(d),C=R[c];for(let D=0;D<x.length;D++){const P=(D+1)%x.length,A=x[D].sum(x[P]).smul(.5),W=(D+2)%x.length,Tt=x[P].sum(x[W]).smul(.5),Kt=lt(m,A),Gt=lt(m,Tt);U(T,x[P],[C,Gt,Kt])}}this.swizzler=new dt(N.map(c=>c[1]));const j=this.swizzler.prefixFree?"":"_",S=ye[this.baseFaceCount],O=[];for(let c=0;c<this.baseFaceCount;c++)O[1<<c]=c;{const c=S.v;for(const x of c){const C=this.swizzler.splitByFaceNames(x);let D=0;for(const P of C)D|=1<<P;O[D]=C[0]}}{const c=S.e;for(const x of c){const C=this.swizzler.splitByFaceNames(x);let D=0;for(const P of C)D|=1<<P;O[D]=C[0]}}{const c=S.c;for(const x of c){const C=this.swizzler.splitByFaceNames(x),D=1<<C[0]|1<<this.baseFaceCount;O[D]=C[1]}}for(let c=0;c<m.length;c++){if(m[c].length!==3)throw new Error(`Bad length in edge names ${m[c]}`);const x=m[c][1],C=m[c][2];let D=R[x];const P=R[C],A=1<<x|1<<C;O[A]===x?D=D+j+P:D=P+j+D,m[c]=[m[c][0],D]}for(let c=0;c<T.length;c++){let x=0;if(T[c].length<4)throw new Error("Bad length in vertex names");for(let A=1;A<T[c].length;A++)x|=1<<L[T[c][A][0]];const C=O[x];let D=-1;for(let A=1;A<T[c].length;A++)C===L[T[c][A][0]]&&(D=A);if(D<0)throw new Error("Internal error; couldn't find face name when fixing corners");let P="";for(let A=1;A<T[c].length;A++){A===1?P=T[c][D][0]:P=P+j+T[c][D][0];for(let W=1;W<T[c].length;W++)if(T[c][D][1]===T[c][W][2]){D=W;break}}T[c]=[T[c][0],P]}this.markedface=O,this.options.verbosity>1&&(console.log(`# Face names: ${N.map(c=>c[1]).join(" ")}`),console.log(`# Edge names: ${m.map(c=>c[1]).join(" ")}`),console.log(`# Vertex names: ${T.map(c=>c[1]).join(" ")}`));const K=[];for(const c of G)K.push([c[0].makenormal(),c[1],"f"]);for(const c of m)K.push([c[0].makenormal(),c[1],"e"]);for(const c of T)K.push([c[0].makenormal(),c[1],"v"]);this.facenames=N,this.faceplanes=G,this.edgenames=m,this.vertexnames=T,this.geonormals=K;const V=K.map(c=>c[1]);this.swizzler.setGripNames(V),this.options.verbosity>0&&console.log(`# Distances: face 1 edge ${this.edgedistance} vertex ${this.vertexdistance}`);for(let c=0;c<B.length;c++)for(const x of this.rotations){const C=B[c].rotateplane(x);let D=!1;for(const P of this.moveplanes)if(C.sameplane(P)){D=!0;break}D||(this.moveplanes.push(C),v[c]&&this.moveplanes2.push(C))}let Q=new ut(d);const X=this.moveplanes2.slice();let q=31;for(let c=0;c<X.length;c++){const x=c+Math.floor((X.length-c)*(q/65536));Q=Q.split(X[x]),X[x]=X[c],q=(q*1657+101)%65536}const Y=Q.collect([],!0);this.faces=Y,this.options.verbosity>0&&console.log(`# Faces is now ${Y.length}`),this.stickersperface=Y.length;const at=[],tt=xt(d);for(const c of this.rotations){const x=c.rotateface(d);tt.dist(xt(x))<H&&at.push(c)}const et=new Array(Y.length),Z=[];for(let c=0;c<Y.length;c++){const x=Y[c].centermass();Z.push([tt.dist(x),x,c])}Z.sort((c,x)=>c[0]-x[0]);for(let c=0;c<Y.length;c++){const x=Z[c][2];if(!et[x]){et[x]=!0;for(const C of at){const D=Y[x].rotate(C),P=D.centermass();for(let A=c+1;A<Y.length&&!(Z[A][0]-Z[c][0]>H);A++){const W=Z[A][2];if(!et[W]&&P.dist(Z[A][1])<H){et[W]=!0,Y[W]=D;break}}}}}this.shortedge=1e99;for(const c of Y)for(let x=0;x<c.length;x++){const C=(x+1)%c.length,D=c.get(x).dist(c.get(C));D<this.shortedge&&(this.shortedge=D)}this.options.verbosity>0&&console.log(`# Short edge is ${this.shortedge}`),e==="c"&&y&&!M&&!z&&(this.addNotationMapper="NxNxNCubeMapper",this.setReidOrder=!0),e==="c"&&z&&!y&&!M&&(this.addNotationMapper="SkewbMapper"),e==="t"&&(z||y)&&!M&&(this.addNotationMapper="PyraminxOrTetraminxMapper"),e==="o"&&y&&(this.notationMapper=new Mt(this.swizzler,new dt(["F","D","L","BL","R","U","BR","B"])),M||z||(this.addNotationMapper="FTOMapper")),e==="d"&&y&&(this.addNotationMapper="MegaminxMapper",this.notationMapper=new Mt(this.swizzler,new dt(["U","F","L","BL","BR","R","FR","FL","DL","B","DR","D"])))}keyface(t){return this.keyface2(t.centermass())}keyface2(t){let e="";const s=String.fromCharCode;for(const n of this.moveplanesets)if(n.length>0){const i=t.dot(n[0]);let o=0,r=1;for(;r*2<=n.length;)r*=2;for(;r>0;r>>=1)o+r<=n.length&&i>n[o+r-1].a&&(o+=r);if(o<47)e=e+s(33+o);else if(o<47+47*47)e=e+s(80+Math.floor(o/47)-1)+s(33+o%47);else if(o<47+47*47+47*47*47)e=e+s(80+Math.floor((o-47)/(47*47)-1))+s(80+Math.floor((o-47)/47)%47)+s(33+o%47);else throw Error("Too many slices for cubie encoding")}return e}keyface3(t){const e=t.centermass(),s=[];for(const n of this.moveplanesets)if(n.length>0){const i=e.dot(n[0]);let o=0,r=1;for(;r*2<=n.length;)r*=2;for(;r>0;r>>=1)o+r<=n.length&&i>n[o+r-1].a&&(o+=r);s.push(o)}return s}findface(t){const e=this.keyface2(t),s=this.facelisthash.get(e);if(s.length===1)return s[0];for(let n=0;n+1<s.length;n++){const i=this.facelisthash.get(e)[n];if(Math.abs(t.dist(this.facecentermass[i]))<H)return i}return s[s.length-1]}project2d(t,e,s){const n=this.facenames[t][0],i=(e+1)%n.length,o=this.baseplanes[t];let r=n[i].sub(n[e]);const b=r.len();r=r.normalize();const l=r.cross(o).normalize();let u=s[1].sub(s[0]);const w=u.len()/b;u=u.normalize();const g=u.b,f=u.c,p=r.smul(g).sub(l.smul(f)).smul(w),a=l.smul(g).sum(r.smul(f)).smul(w),d=new $(0,s[0].b-p.dot(n[e]),s[0].c-a.dot(n[e]),0);return[p,a,d]}allstickers(){this.faces=be(this.baseplanerot,this.faces),this.options.verbosity>0&&console.log(`# Total stickers is now ${this.faces.length}`),this.facecentermass=new Array(this.faces.length);for(let m=0;m<this.faces.length;m++)this.facecentermass[m]=this.faces[m].centermass();const t=[],e=[];for(const m of this.moveplanes){const F=m.makenormal();let U=!1;for(const E of e)F.sameplane(E.makenormal())&&(U=!0);U||(e.push(F),t.push([]))}for(const m of this.moveplanes2){const F=m.makenormal();for(let U=0;U<e.length;U++)if(F.sameplane(e[U])){t[U].push(m);break}}for(let m=0;m<t.length;m++){const F=t[m].map(E=>E.normalizeplane()),U=e[m];for(let E=0;E<F.length;E++)F[E].makenormal().dist(U)>H&&(F[E]=F[E].smul(-1));F.sort((E,L)=>E.a-L.a),t[m]=F}this.moveplanesets=t,this.moveplanenormals=e;const s=t.map(m=>m.length);this.options.verbosity>0&&console.log(`# Move plane sets: ${s}`);const n=[];for(let m=0;m<t.length;m++)n.push([]);for(const m of this.rotations){if(Math.abs(Math.abs(m.a)-1)<H)continue;const F=m.makenormal();for(let U=0;U<t.length;U++)if(F.sameplane(e[U])){n[U].push(m);break}}this.moverotations=n;for(let m=0;m<n.length;m++){const F=n[m],U=F[0].makenormal();for(let E=0;E<F.length;E++)U.dist(F[E].makenormal())>H&&(F[E]=F[E].smul(-1));F.sort((E,L)=>E.angle()-L.angle()),n[m][0].dot(e[m])<0&&F.reverse()}const i=n.map(m=>1+m.length);this.movesetorders=i;const o=[];let r="?";for(let m=0;m<t.length;m++){const F=e[m];let U=null,E=null;for(const L of this.geonormals){const R=F.dot(L[0]);Math.abs(R-1)<H?(E=[L[1],L[2]],r=L[2]):Math.abs(R+1)<H&&(U=[L[1],L[2]],r=L[2])}if(E===null||U===null)throw new Error("Saw positive or negative sides as null");o.push([E[0],E[1],U[0],U[1],1+t[m].length]),this.addNotationMapper==="NxNxNCubeMapper"&&r==="f"&&(this.notationMapper=new Jt(1+t[m].length),this.addNotationMapper=""),this.addNotationMapper==="SkewbMapper"&&t[0].length===1&&(this.notationMapper=new te(this.swizzler),this.addNotationMapper=""),this.addNotationMapper==="PyraminxOrTetraminxMapper"&&(t[0].length===2&&t[0][0].a===.333333333333333&&t[0][1].a===1.66666666666667?(this.notationMapper=new It(this.swizzler),this.addNotationMapper=""):(this.notationMapper=new Vt(this.swizzler),this.addNotationMapper="")),this.addNotationMapper==="MegaminxMapper"&&r==="f"&&(1+t[m].length===3&&(this.notationMapper=new Wt(this.notationMapper)),this.addNotationMapper=""),this.addNotationMapper==="FTOMapper"&&r==="f"&&(1+t[m].length===3&&(this.notationMapper=new Zt(this.notationMapper,this.swizzler)),this.addNotationMapper="")}this.movesetgeos=o;const b=new Map,l=this.faces;for(let m=0;m<l.length;m++){const F=l[m],U=this.keyface(F);if(!b.get(U))b.set(U,[m]);else{const E=b.get(U);if(E.push(m),E.length===this.baseFaceCount){this.options.verbosity>0&&console.log("# Splitting core.");for(let L=0;L<E.length;L++){const R=`${U} ${L}`;b.set(R,[E[L]])}}}}this.facelisthash=b,this.options.verbosity>0&&console.log(`# Cubies: ${b.size}`);const u=[],w=[],g=[];for(const m of b.values())if(m.length!==this.baseFaceCount){if(m.length>1){const F=m.map(j=>l[j].centermass()),U=xt(F);for(let j=0;m.length>2;j++){let S=!1;for(let O=0;O<m.length;O++){const K=(O+1)%m.length;if(U.dot(F[O].cross(F[K]))<0){const V=F[O];F[O]=F[K],F[K]=V;const Q=m[O];m[O]=m[K],m[K]=Q,S=!0}}if(!S)break;if(j>1e3)throw new Error("Bad epsilon math; too close to border")}let E=0;for(const j of m)E|=1<<Math.floor(j/this.stickersperface);const L=this.markedface[E];let R=-1;for(let j=0;j<m.length;j++)Math.floor(m[j]/this.stickersperface)===L&&(R=j);if(R<0)throw new Error("Could not find marked face in list");if(R!==0){const j=m.slice();for(let S=0;S<m.length;S++)m[S]=j[(R+S)%m.length]}}for(let F=0;F<m.length;F++){const U=m[F];w[U]=u.length,g[U]=F}u.push(m)}this.cubies=u,this.facetocubie=w,this.facetoord=g;const f=["?","CENTERS","EDGES","CORNERS","C4RNER","C5RNER"],p=[],a=[0,0,0,0,0,0],d=[],B=[];let v=0;const y=[],M=[],z=[],N=[],G=m=>u[m].map(F=>this.getfaceindex(F)).join(" "),T=[];for(let m=0;m<u.length;m++){const F=u[m];if(F.length===0||B[m])continue;const U={};let E=0;z.push(0),T.push([]);const L=F.length,R=a[L]++;let j=f[L];(j===void 0||L===this.baseFaceCount)&&(j="CORE"),j=j+(R===0?"":R+1),p[v]=j,d[v]=L;const S=[m];let O=0;for(B[m]=!0;O<S.length;){const K=S[O++],V=G(K);if((F.length>1||U[V]===void 0)&&(U[V]=E++),N[K]=U[V],y[K]=v,T[v].push(K),M[K]=z[v]++,S.length<this.rotations.length){const Q=this.facecentermass[u[K][0]];for(const X of n){const q=this.facetocubie[this.findface(Q.rotatepoint(X[0]))];B[q]||(S.push(q),B[q]=!0)}}}v++}if(this.setReidOrder&&4<=this.stickersperface&&this.stickersperface<=9){const m=[["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],["UFR","URB","UBL","ULF","DRF","DFL","DLB","DBR"],["U","L","F","R","B","D"]],F={};for(const U of m)for(let E=0;E<U.length;E++){let L=0;for(let R=0;R<U[E].length;R++)L|=1<<U[E].charCodeAt(R)-65;F[L]=E}for(const U of T)for(const E of U){let L=0;for(const R of u[E])L|=1<<this.facenames[this.getfaceindex(R)][1].charCodeAt(0)-65;M[E]=F[L]}}if(this.cubiesetnums=y,this.cubieordnums=M,this.cubiesetnames=p,this.cubieords=z,this.orbitoris=d,this.cubievaluemap=N,this.cubiesetcubies=T,this.options.fixedPieceType!==null){for(let m=0;m<u.length;m++)if(this.options.fixedPieceType==="v"&&u[m].length>2||this.options.fixedPieceType==="e"&&u[m].length===2||this.options.fixedPieceType==="f"&&u[m].length===1){this.fixedCubie=m;break}if(this.fixedCubie<0)throw new Error(`Could not find a cubie of type ${this.options.fixedPieceType} to fix.`)}this.options.verbosity>0&&console.log(`# Cubie orbit sizes ${z}`)}unswizzle(t){const e=this.notationMapper.notationToInternal(t);return e===null?null:e.modified({family:this.swizzler.unswizzle(e.family)})}stringToBlockMove(t){const e=/^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$/,s=t.match(e);if(s===null)throw new Error(`Bad move passed ${t}`);const n=s[4];let i,o;if(s[2]!==void 0){if(s[3]===void 0)throw new Error("Missing second number in range");i=parseInt(s[2],10)}s[3]!==void 0&&(o=parseInt(s[3],10));let r="1",b=1;return s[5]!==void 0&&(r=s[5],r[0]==="'"&&(r=`-${r.substring(1)}`),b=parseInt(r,10)),new k(new I(n,o,i),b)}parseMove(t){const e=this.notationMapper.notationToInternal(t);if(e===null)throw new Error(`Bad move ${t.family}`);t=e;let s=t.family,n=!1;if(s.endsWith("v")&&s[0]<="Z"){if(t.innerLayer!==void 0||t.outerLayer!==void 0)throw new Error("Cannot use a prefix with full cube rotations");s=s.slice(0,-1),n=!0}s.endsWith("w")&&s[0]<="Z"&&(s=s.slice(0,-1).toLowerCase());let i,o=-1;const r=this.swizzler.unswizzle(s);let b=!1;for(let w=0;w<this.movesetgeos.length;w++){const g=this.movesetgeos[w];r===g[0]&&(b=!0,i=g,o=w),r===g[2]&&(b=!1,i=g,o=w)}let l=1,u=1;if(s.toUpperCase()!==s&&(u=2),i===void 0)throw new Error(`Bad grip in move ${t.family}`);if(t.outerLayer!==void 0&&(l=t.outerLayer),t.innerLayer!==void 0&&(t.outerLayer===void 0?(u=t.innerLayer,s<="Z"?l=u:l=1):u=t.innerLayer),l--,u--,n&&(l=0,u=this.moveplanesets[o].length),l<0||l>this.moveplanesets[o].length||u<0||u>this.moveplanesets[o].length)throw new Error(`Bad slice spec ${l} ${u} vs ${this.moveplanesets[o].length}`);if(l===0&&u===this.moveplanesets[o].length&&!n)throw new Error("! full puzzle rotations must be specified with v suffix.");return[void 0,o,l,u,b,t.amount]}parsemove(t){const e=this.parseMove(this.stringToBlockMove(t));return e[0]=t,e}genperms(){if(this.cmovesbyslice.length>0)return;const t=[];if(this.options.orientCenters){for(let e=0;e<this.cubies.length;e++)if(this.cubies[e].length===1){const s=this.cubies[e][0],n=this.getfaceindex(s),i=this.basefaces[n].centermass();if(i.dist(this.facecentermass[s])<H){const o=1<<n|1<<this.baseFaceCount,r=this.markedface[o],b=this.baseplanes[r].makenormal();let l=-1,u=-1;for(let f=0;f<this.faces[s].length;f++){const p=this.faces[s].get(f),a=b.dot(p.sub(i));a>l&&(l=a,u=f)}const w=(u+1)%this.faces[s].length;if(Math.abs(b.dot(this.faces[s].get(w).sub(i))-l)<H&&(u=w),u!==0){const f=[];for(let p=0;p<this.faces[s].length;p++)f.push(this.faces[s].get((p+u)%this.faces[s].length));this.faces[s]=new rt(f)}const g=this.basefaces[n].length;for(let f=1;f<g;f++)this.cubies[e].push(this.cubies[e][f-1]);this.duplicatedFaces[s]=g,this.duplicatedCubies[e]=g,this.orbitoris[this.cubiesetnums[e]]=g}}}for(let e=0;e<this.moveplanesets.length;e++){const s=this.moveplanesets[e],n=[],i=[s.length+1,0];let o=1;for(;o*2<=s.length;)o*=2;for(let l=0;l<this.faces.length;l++){let u=0;if(s.length>0){const w=this.facecentermass[l].dot(s[0]);for(let g=o;g>0;g>>=1)u+g<=s.length&&w>s[u+g-1].a&&(u+=g);u=s.length-u}for(n.push(u);i.length<=u;)i.push(0);i[u]++}const r=new Array(i.length);for(let l=0;l<i.length;l++)r[l]=[];const b=[];for(let l=0;l<this.faces.length;l++){if(n[l]<0)continue;const u=[this.facetocubie[l],this.facetoord[l]];let w=this.facecentermass[l];const g=w;let f=l;const p=n[f];for(;;){n[f]=-1;const a=w.rotatepoint(this.moverotations[e][0]);if(a.dist(g)<H)break;f=this.findface(a),u.push(this.facetocubie[f],this.facetoord[f]),w=a}if(u.length>2&&this.options.orientCenters&&(this.cubies[u[0]].length===1||this.duplicatedCubies[u[0]]>1)&&this.facecentermass[l].dist(this.basefaces[this.getfaceindex(l)].centermass())<H){let a=this.faces[this.cubies[u[0]][0]];for(let d=0;d<u.length;d+=2){const B=this.faces[this.cubies[u[d]][0]];let v=-1;for(let y=0;y<a.length;y++)if(B.get(y).dist(a.get(0))<H){v=y;break}if(v<0)throw new Error("Couldn't find rotation of center faces; ignoring for now.");u[d+1]=v,a=a.rotate(this.moverotations[e][0])}}if(u.length===2&&this.options.orientCenters){const a=this.facecentermass[l].dot(this.moveplanenormals[e]);for(let d=1;d<this.movesetorders[e];d++)a>0?u.push(u[0],d):u.push(u[0],(this.movesetorders[e]-d)%this.movesetorders[e])}if(u.length>2&&!b[u[0]]){if(u.length!==2*this.movesetorders[e])throw new Error("Bad length in perm gen");for(const a of u)r[p].push(a)}for(let a=0;a<u.length;a+=2)b[u[a]]=!0}for(let l=0;l<r.length;l++)r[l]=r[l].slice();t.push(r)}if(this.cmovesbyslice=t,this.options.moveList){const e=[];for(const s of this.options.moveList)e.push(this.parsemove(s));this.parsedmovelist=e}this.facelisthash.clear(),this.facecentermass=[]}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(t){const e=this.moveplanesets[t].length;let s=[];if(this.parsedmovelist!==void 0)for(const n of this.parsedmovelist)n[1]===t&&(n[4]?s.push([n[2],n[3]]):s.push([e-n[3],e-n[2]]),s.push(n[5]));else if(this.options.vertexMoves&&!this.options.allMoves){const n=this.movesetgeos[t];if(n[1]!==n[3])for(let i=0;i<e;i++)n[1]!=="v"?(this.options.outerBlockMoves?s.push([i+1,e]):s.push([i+1]),s.push(1)):(this.options.outerBlockMoves?s.push([0,i]):s.push([i,i]),s.push(1))}else for(let n=0;n<=e;n++)!this.options.allMoves&&n+n===e||(this.options.outerBlockMoves?n+n>e?s.push([n,e]):s.push([0,n]):s.push([n,n]),s.push(1));if(this.fixedCubie>=0){const n=this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[t],i=[];for(let o=0;o<s.length;o+=2){let r=s[o];if(n>=r[0]&&n<=r[1])if(r[0]===0)r=[r[1]+1,e];else if(e===r[1])r=[0,r[0]-1];else throw Error("fixed cubie option would disconnect move");let b=!1;for(let l=0;l<i.length;l+=2)if(i[l][0]===r[0]&&i[l][1]===r[1]&&i[l+1]===s[o+1]){b=!0;break}b||(i.push(r),i.push(s[o+1]))}s=i}return s}graybyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),e===1&&(this.options.grayCenters||!this.options.includeCenterOrbits)||e===2&&(this.options.grayEdges||!this.options.includeEdgeOrbits)||e>2&&(this.options.grayCorners||!this.options.includeCornerOrbits)}skipbyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),e===1&&!this.options.includeCenterOrbits||e===2&&!this.options.includeEdgeOrbits||e>2&&!this.options.includeCornerOrbits}skipcubie(t){return this.skipbyori(t)}header(t){return`${t+we}
${t}
`}writegap(){const t=this.getOrbitsDef(!1),e=[],s=[];for(let i=0;i<t.moveops.length;i++){let o=`M_${ct(this.notationMapper,t.movenames[i])}`,r=!1;o[o.length-1]==="'"&&(o=o.substring(0,o.length-1),r=!0),s.push(o),r?e.push(`${o}:=${t.moveops[i].toPerm().inv().toGap()};`):e.push(`${o}:=${t.moveops[i].toPerm().toGap()};`)}e.push("Gen:=["),e.push(s.join(",")),e.push("];");const n=t.solved.identicalPieces();return e.push(`ip:=[${n.map(i=>`[${i.map(o=>o+1).join(",")}]`).join(",")}];`),e.push("# Size(Group(Gen));"),e.push("# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));"),e.push(""),this.header("# ")+e.join(`
`)}writemathematica(){const t=this.getOrbitsDef(!1),e=[],s=[];e.push(`(* ${this.header("").trim()} *)`);for(let n=0;n<t.moveops.length;n++){let i=`m${ct(this.notationMapper,t.movenames[n])}`,o=!1;i[i.length-1]==="'"&&(i=i.substring(0,i.length-1),o=!0),s.push(i),o?e.push(`${i}=${t.moveops[n].toPerm().inv().toMathematica()};`):e.push(`${i}=${t.moveops[n].toPerm().toMathematica()};`)}return e.push(`gen={${s.join(",")}};`),e.join(`
`)}writeksolve(t="PuzzleGeometryPuzzle"){const e=this.getOrbitsDef(!1);return this.header("# ")+e.toKsolve(t,this.notationMapper).join(`
`)}getKPuzzleDefinition(t=!0,e=!0){const n=this.getOrbitsDef(t,e).toKPuzzleDefinition(e);if(n.experimentalPuzzleDescription=this.puzzleDescription,!n)throw new Error("Missing definition!");return n}getMoveFromBits(t,e,s,n,i,o){const r=[],b=[],l=[];for(const g of this.cubieords)b.push(st(g)),l.push(it(g));for(let g=t[0];g<=t[1];g++){const f=n[g];for(let p=0;p<f.length;p+=2*o){const a=f.slice(p,p+2*o),d=this.cubiesetnums[a[0]];for(let y=0;y<a.length;y+=2)a[y]=this.cubieordnums[a[y]];let B=2,v=3;s&&(B=a.length-2,v=a.length-1),b[d]===st(this.cubieords[d])&&(b[d]=b[d].slice(),this.orbitoris[d]>1&&!this.options.fixedOrientation&&(l[d]=l[d].slice()));for(let y=0;y<a.length;y+=2)b[d][a[(y+B)%a.length]]=a[y],this.orbitoris[d]>1&&!this.options.fixedOrientation&&(l[d][a[y]]=(a[(y+v)%a.length]-a[(y+1)%a.length]+2*this.orbitoris[d])%this.orbitoris[d])}}let u=new J(st(24),it(24),1);for(let g=0;g<this.cubiesetnames.length;g++)if(!(i&&!i[g]))if(this.orbitoris[g]===1||this.options.fixedOrientation)b[g]===st(u.perm.length)?(b[g]!==u.perm&&(u=new J(b[g],l[g],1)),r.push(u)):r.push(new J(b[g],l[g],1));else{const f=new Array(l[g].length);for(let p=0;p<b[g].length;p++)f[p]=l[g][b[g][p]];r.push(new J(b[g],f,this.orbitoris[g]))}let w=new ot(r);return e!==1&&(w=w.mulScalar(e)),w}omitSet(t){for(const e of this.options.excludeOrbits)if(e===t)return!0;return!1}diffmvsets(t,e,s,n){for(let i=0;i<t.length;i+=2){let o=!1;for(let r=0;!o&&r<e.length;r+=2)n?t[i][0]+e[r][1]===s&&t[i][1]+e[r][0]===s&&t[i+1]===e[r+1]&&(o=!0):t[i][0]===e[r][0]&&t[i][1]===e[r][1]&&t[i+1]===e[r+1]&&(o=!0);if(!o)return!0}return!1}getOrbitsDef(t,e=!0){const s=[];if(t)for(let a=0;a<this.cubiesetnames.length;a++)s.push(1);const n=[],i=[],o=[],r=[];for(let a=0;a<this.moveplanesets.length;a++){const d=this.getmovesets(a);o.push(d),this.options.addRotations?r.push(1):r.push(0)}const b=[];for(let a=0;a<this.moveplanesets.length;a++){const d=this.moveplanesets[a].length;let B=!1;const v=o[a];for(let y=0;y<v.length;y+=2)v[y][0]===0&&v[y][1]===d&&(B=!0);b[a]=B}if(this.options.addRotations&&(this.options.moveList||this.options.fixedPieceType!==null)){for(let a=0;a<this.moverotations.length;a++)r[a]=0;for(let a=0;a<this.moveplanesets.length;a++){if(b[a]){r[a]=3;continue}for(let d=0;d<this.moverotations.length;d++){let B=this.moveplanenormals[a];for(let v=1;v*2<=this.movesetorders[d];v++){if(B=B.rotatepoint(this.moverotations[d][0]),r[d]&v)continue;let y=-1,M=!1;for(let N=0;N<this.moveplanenormals.length;N++)if(B.dist(this.moveplanenormals[N])<H){y=N;break}else if(B.dist(this.moveplanenormals[N].smul(-1))<H){y=N,M=!0;break}if(y<0)throw new Error("Could not find rotation");const z=o[y];(z.length!==o[a].length||this.moveplanesets[a].length!==this.moveplanesets[y].length||this.diffmvsets(z,o[a],this.moveplanesets[y].length,M))&&(r[d]|=v)}}}for(let a=0;a<this.moverotations.length;a++)if(r[a]===0)r[a]=1;else if(r[a]===1)this.movesetorders[a]>3?r[a]=2:r[a]=0;else if(r[a]===3)r[a]=0;else throw new Error("Impossible addrot val")}for(let a=0;a<this.moveplanesets.length;a++)r[a]!==0&&!b[a]&&(o[a].push([0,this.moveplanesets[a].length]),o[a].push(r[a]));for(let a=0;a<this.moveplanesets.length;a++){const d=o[a],B=this.movesetorders[a];for(let M=0;M<d.length;M+=2)for(let z=0;z<M;z+=2)if(d[M][0]===d[z][0]&&d[M][1]===d[z][1])throw new Error("Redundant moves in moveset.");const v=[];for(let M=0;M<d.length;M+=2)for(let z=d[M][0];z<=d[M][1];z++)v[z]=1;const y=this.cmovesbyslice[a];for(let M=0;M<y.length;M++){if(v[M]!==1)continue;const z=y[M];for(let N=0;N<z.length;N+=2*B){if(this.skipcubie(z[N]))continue;const G=this.cubiesetnums[z[N]];s[G]=1}}}for(let a=0;a<this.cubiesetnames.length;a++)if(s[a]){if(this.omitSet(this.cubiesetnames[a])){s[a]=0;continue}n.push(this.cubiesetnames[a]),i.push(new Bt(this.cubieords[a],this.options.fixedOrientation?1:this.orbitoris[a]))}const l=[];for(let a=0;a<this.cubiesetnames.length;a++){if(!s[a]||this.omitSet(this.cubiesetnames[a]))continue;const d=[],B=[];for(let v=0;v<this.cubieords[a];v++){if(t)d.push(v);else{const y=this.cubiesetcubies[a][v];d.push(this.cubievaluemap[y])}B.push(0)}l.push(new J(d,B,this.options.fixedOrientation?1:this.orbitoris[a]))}const u=[],w=[],g=[],f=[];if(e)for(let a=0;a<this.moveplanesets.length;a++){const B=this.moveplanesets[a].length,v=o[a],y=this.movesetgeos[a];for(let M=0;M<v.length;M+=2){const z=v[M];let N,G=!1;if(this.parsedmovelist!==void 0)for(const m of this.parsedmovelist){if(m[1]!==a)continue;let F=[];m[4]?F=[m[2],m[3]]:F=[B-m[3],B-m[2]],F[0]===z[0]&&F[1]===z[1]&&(N=m[0],G=!m[4])}if(N)u.push(N),w.push(!0);else{const m=Be(y,z,B);G=m[1];const F=m[0];v[M+1]===1?u.push(F):u.push(F+v[M+1]),w.push(!1)}f.push(z[0]===0&&z[1]===B);const T=this.getMoveFromBits(z,v[M+1],G,this.cmovesbyslice[a],s,this.movesetorders[a]);g.push(T)}}let p=new mt(n,i,new pt(l),u,g,f,w);return this.options.optimizeOrbits&&(p=p.optimize()),this.options.scrambleAmount!==0&&p.scramble(this.options.scrambleAmount),p}getScramble(t=0){const e=this.getOrbitsDef(!1);return e.toKTransformationData(e.getScrambleTransformation(t))}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map(t=>t.toPerm())}showcanon(t){ae(this.getOrbitsDef(!1),t)}getsolved(){const t=[];for(let e=0;e<this.baseFaceCount;e++)for(let s=0;s<this.stickersperface;s++)t.push(e);return new _(t)}getOrientationRotation(t){const[e,[s,n,i]]=t[0],o=new $(0,s,-n,i),[r,[b,l,u]]=t[1],w=new $(0,b,-l,u);let g=null,f=null;const p=this.swizzler.unswizzle(e),a=this.swizzler.unswizzle(r);for(const y of this.geonormals)p===y[1]&&(g=y[0]),a===y[1]&&(f=y[0]);if(!g)throw new Error(`Could not find feature ${e}`);if(!f)throw new Error(`Could not find feature ${r}`);const d=g.pointrotation(o);return f.rotatepoint(d).unproject(o).pointrotation(w.unproject(o)).mul(d)}getInitial3DRotation(){const t=this.baseFaceCount;let e=null;if(this.options.puzzleOrientation?e=this.options.puzzleOrientation:this.options.puzzleOrientations&&(e=this.options.puzzleOrientations[t]),e||(e=xe()[t]),!e)throw new Error("No default orientation?");return this.getOrientationRotation(e)}generate2dmapping(t=800,e=500,s=10,n=!1,i=.92){t-=2*s,e-=2*s;function o(L,R){let j=L[1][0]-L[0][0],S=L[1][1]-L[0][1];const O=2*Math.PI/R,K=Math.cos(O),V=Math.sin(O);for(let Q=2;Q<R;Q++){const X=j*K+S*V;S=S*K-j*V,j=X,L.push([L[Q-1][0]+j,L[Q-1][1]+S])}}this.genperms();const l=this.getboundarygeometry().facenames[0][0].length,u=this.net;if(u===null)throw new Error("No net?");const w={};let g=0,f=0,p=1,a=0;w[u[0][0]]=[[1,0],[0,0]],o(w[u[0][0]],l);for(const L of u){const R=L[0];if(!w[R])throw new Error("Bad edge description; first edge not connected.");for(let j=1;j<L.length;j++){const S=L[j];S===""||w[S]||(w[S]=[w[R][j%l],w[R][(j+l-1)%l]],o(w[S],l))}}for(const L in w){const R=w[L];for(const j of R)g=Math.min(g,j[0]),p=Math.max(p,j[0]),f=Math.min(f,j[1]),a=Math.max(a,j[1])}const d=Math.min(t/(p-g),e/(a-f)),B=.5*(t-d*(p+g)),v=.5*(e-d*(a+f)),y={},M=this.getboundarygeometry(),z={},N=[[d+B,v],[B,v]];z[u[0][0]]=N,o(z[u[0][0]],l),y[this.facenames[0][1]]=this.project2d(0,0,[new $(0,N[0][0],N[0][1],0),new $(0,N[1][0],N[1][1],0)]);const G=[];G[0]=0;for(const L of u){const R=L[0];if(!z[R])throw new Error("Bad edge description; first edge not connected.");let j=-1;for(let O=0;O<M.facenames.length;O++)if(R===M.facenames[O][1]){j=O;break}if(j<0)throw new Error(`Could not find first face name ${R}`);const S=M.facenames[j][0];for(let O=1;O<L.length;O++){const K=L[O];if(K===""||z[K])continue;z[K]=[z[R][O%l],z[R][(O+l-1)%l]],o(z[K],l);const V=G[j],Q=S[(V+O)%l].sum(S[(V+O+l-1)%l]).smul(.5),X=lt(M.edgenames,Q),q=M.edgenames[X][1],Y=Fe(q,this.facenames),at=Y[R===Y[0]?1:0];let tt=-1;for(let Z=0;Z<M.facenames.length;Z++)if(at===M.facenames[Z][1]){tt=Z;break}if(tt<0)throw new Error("Could not find second face name");const et=M.facenames[tt][0];for(let Z=0;Z<et.length;Z++)if(et[Z].sum(et[(Z+1)%l]).smul(.5).dist(Q)<=H){const x=z[R][(O+l-1)%l],C=z[R][O%l];G[tt]=Z,y[at]=this.project2d(tt,Z,[new $(0,C[0],C[1],0),new $(0,x[0],x[1],0)]);break}}}let T=0,m=0;const F=this.getInitial3DRotation();for(let L of this.faces){n&&(L=L.rotate(F));for(let R=0;R<L.length;R++)T=Math.max(T,Math.abs(L.get(R).b)),m=Math.max(m,Math.abs(L.get(R).c))}const U=Math.min(e/m/2,(t-s)/T/4);return(L,R)=>{if(n){R=R.rotatepoint(F);const j=.5*s+.25*t,S=this.baseplanes[L].rotateplane(F).d<0?1:-1;return[s+t*.5+S*(j-R.b*U),s+e*.5+R.c*U]}else{const j=y[this.facenames[L][1]];return[s+i*R.dot(j[0])+j[2].b,s+e-i*R.dot(j[1])-j[2].c]}}}generatesvg(t=800,e=500,s=10,n=!1){const i=this.generate2dmapping(t,e,s,n);function o(g,f,p){return`<polygon id="${g}" class="sticker" style="fill: ${p}" points="${f.map(a=>`${a[0]} ${a[1]}`).join(" ")}"/>
`}const r=this.getsolved(),b=[],l=[];for(let g=0;g<this.baseFaceCount;g++)b[g]=this.colors[this.facenames[g][1]];for(let g=0;g<this.faces.length;g++){const f=this.faces[g],p=Math.floor(g/this.stickersperface),a=[];for(let d=0;d<f.length;d++)a.push(i(p,f.get(d)));l.push(a)}const u=[];for(let g=0;g<this.baseFaceCount;g++){u.push("<g>"),u.push(`<title>${this.facenames[g][1]}</title>
`);for(let f=0;f<this.stickersperface;f++){const p=g*this.stickersperface+f,a=this.facetocubie[p],d=this.facetoord[p],B=this.cubiesetnums[a],v=this.cubieordnums[a],y=this.graybyori(a)?"#808080":b[r.p[p]];let M=`${this.cubiesetnames[B]}-l${v}-o${d}`;if(u.push(o(M,l[p],y)),this.duplicatedFaces[p])for(let z=1;z<this.duplicatedFaces[p];z++)M=`${this.cubiesetnames[B]}-l${v}-o${z}`,u.push(o(M,l[p],y))}u.push("</g>")}return`<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">
<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>
${u.join("")}</svg>`}get3d(t){const e=[],s=this.getInitial3DRotation(),n=[],i=.52*this.basefaces[0].get(0).len();for(let l=0;l<this.basefaces.length;l++){const u=this.basefaces[l].rotate(s),w=this.facenames[l][1];n.push({coords:Lt(u,i),name:w})}for(let l=0;l<this.faces.length;l++){const u=Math.floor(l/this.stickersperface),w=this.facetocubie[l],g=this.facetoord[l],f=this.cubiesetnums[w],p=this.cubieordnums[w];let a=this.graybyori(w)?t?.darkIgnoredOrbits?"#222222":"#808080":this.colors[this.facenames[u][1]];t?.stickerColors&&(a=t.stickerColors[l]);const d=this.faces[l].rotate(s);e.push({coords:Lt(d,i),color:a,orbit:this.cubiesetnames[f],ord:p,ori:g,face:u});let B=d;if(this.duplicatedFaces[l]){const v=B.length/this.duplicatedFaces[l];for(let y=1;y<this.duplicatedFaces[l];y++){for(let M=0;M<v;M++)B=B.rotateforward();e.push({coords:Lt(B,i),color:a,orbit:this.cubiesetnames[f],ord:p,ori:y,face:u,isDup:!0})}}}const o=[];for(let l=0;l<this.movesetgeos.length;l++){const u=this.movesetgeos[l],w=this.movesetorders[l];for(const g of this.geonormals)u[0]===g[1]&&u[1]===g[2]&&(o.push({coordinates:ht(g[0].rotatepoint(s),1),quantumMove:new k(u[0]),order:w}),o.push({coordinates:ht(g[0].rotatepoint(s).smul(-1),1),quantumMove:new k(u[2]),order:w}))}const r=this.generate2dmapping(2880,2160,0,!1,1),b=(()=>{const l=s.invrot();return(u,w)=>{let g=new $(0,w[0]*i,-w[1]*i,w[2]*i);g=g.rotatepoint(l);const f=r(u,g);return f[0]/=2880,f[1]=1-f[1]/2160,f}})().bind(this);return{stickers:e,faces:n,axis:o,unswizzle:this.unswizzle.bind(this),notationMapper:this.notationMapper,textureMapper:{getuv:b}}}getGeoNormal(t){const e=this.getInitial3DRotation(),s=this.swizzler.unswizzle(t);for(const n of this.geonormals)if(s===n[1]){const i=ht(n[0].rotatepoint(e),1);return Math.abs(i[0])<H&&Math.abs(i[2])<H&&(i[0]=0,i[2]=1e-6),i}}getfaceindex(t){const e=this.stickersperface;return Math.floor(t/e)}textForTwizzleExplorer(){return`Faces ${this.baseplanerot.length}
Stickers per face ${this.stickersperface}
Short edge ${this.shortedge}
Cubies ${this.cubies.length}
Edge distance ${this.edgedistance}
Vertex distance ${this.vertexdistance}`}writeSchreierSims(t){const s=this.getOrbitsDef(!1).reassemblySize();t(`Reassembly size is ${s}`);const n=ge(this.getMovesAsPerms(),t),i=s/n;t(`Ratio is ${i}`)}}class Ue{constructor(t,e){this.pg=t,this.orbitNames=e.orbitnames}orbitNames;lookupMove(t){const e=this.pg.parseMove(t);if(this.pg.parsedmovelist){let o=!1;for(const r of this.pg.parsedmovelist)r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]&&r[4]===e[4]&&(o=!0);if(!o)return null}let s=[e[2],e[3]];if(!e[4]){const o=this.pg.moveplanesets[e[1]].length;s=[o-e[3],o-e[2]]}const n=this.pg.getMoveFromBits(s,e[5],!e[4],this.pg.cmovesbyslice[e[1]],void 0,this.pg.movesetorders[e[1]]);return mt.transformToKTransformationData(this.orbitNames,n)}remapKPuzzleDefinition(t){return ee(t,this.pg.notationMapper)}}export{Ee as EXPERIMENTAL_PUZZLE_BASE_SHAPES,je as EXPERIMENTAL_PUZZLE_CUT_TYPES,Ue as ExperimentalPGNotation,Me as PuzzleGeometry,$ as Quat,De as getPG3DNamedPuzzles,ke as getPuzzleDescriptionString,Le as getPuzzleGeometryByDesc,Ce as getPuzzleGeometryByName,ze as parseOptions,At as parsePuzzleDescription,ge as schreierSims};
