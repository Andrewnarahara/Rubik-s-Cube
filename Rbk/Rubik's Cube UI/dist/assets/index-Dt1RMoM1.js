var Wt=Object.defineProperty;var Jt=(h,t,e)=>t in h?Wt(h,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[t]=e;var w=(h,t,e)=>Jt(h,typeof t!="symbol"?t+"":t,e);import{M as E,Q as N}from"./index-C4VQUX2B.js";function Qt(){return{4:{F:"#44ee00",D:"#f4f400",L:"#ff0000",R:"#2266ff"},6:{U:"#ffffff",F:"#44ee00",R:"#ff0000",D:"#f4f400",B:"#2266ff",L:"#ff8000"},8:{U:"#ffffff",F:"#44ee00",R:"#ff0000",D:"#f4f400",BB:"#2266ff",L:"#8800dd",BL:"#ff8000",BR:"#888888"},12:{U:"#ffffff",F:"#008800",R:"#ff0000",C:"#e8d0a0",A:"#3399ff",L:"#8800dd",E:"#ff66cc",BF:"#99ff00",BR:"#0000ff",BL:"#f4f400",I:"#ff8000",D:"#888888"},20:{R:"#f4f400",C:"#d41f69",F:"#008800",E:"#5c5c5c",L:"#8800dd",U:"#ffffff",A:"#007a89",G:"#ff0000",I:"#7d3b11",S:"#b9a1ff",H:"#3399ff",J:"#5ec4b6",B:"#44ee00",K:"#e8d0a0",D:"#aaaaaa",M:"#ff66cc",O:"#292929",P:"#ff8000",N:"#980000",Q:"#0000ff"}}}class bt{constructor(t,e){w(this,"prefixFree",!0);w(this,"gripnames",[]);this.facenames=t,e&&(this.gripnames=e);for(let s=0;this.prefixFree&&s<t.length;s++)for(let i=0;this.prefixFree&&i<t.length;i++)s!==i&&t[s].startsWith(t[i])&&(this.prefixFree=!1)}setGripNames(t){this.gripnames=t}splitByFaceNames(t){const e=[];let s=0;for(;s<t.length;){s>0&&s<t.length&&t[s]==="_"&&s++;let i=-1;for(let n=0;n<this.facenames.length;n++)t.substr(s).startsWith(this.facenames[n])&&(i<0||this.facenames[n].length>this.facenames[i].length)&&(i=n);if(i>=0)e.push(i),s+=this.facenames[i].length;else throw new Error(`Could not split ${t} into face names.`)}return e}joinByFaceIndices(t){let e="";const s=[];for(let i=0;i<t.length;i++)s.push(e),s.push(this.facenames[t[i]]),this.prefixFree||(e="_");return s.join("")}spinmatch(t,e){if(t===e)return!0;try{const s=this.splitByFaceNames(t),i=this.splitByFaceNames(e);if(s.length!==i.length&&s.length<3)return!1;for(let n=0;n<s.length;n++){for(let r=0;r<n;r++)if(s[n]===s[r])return!1;let o=!1;for(let r=0;r<i.length;r++)if(s[n]===i[r]){o=!0;break}if(!o)return!1}return!0}catch{return!1}}spinmatchv(t,e){return t.endsWith("v")&&e.endsWith("v")?this.spinmatch(t.slice(0,t.length-1),e.slice(0,e.length-1)):this.spinmatch(t,e)}unswizzle(t){(t.endsWith("v")||t.endsWith("w"))&&t[0]<="Z"&&(t=t.slice(0,t.length-1));const e=t.toUpperCase();for(let s=0;s<this.gripnames.length;s++){const i=this.gripnames[s];if(this.spinmatch(e,i))return i}return t}}class Nt{notationToInternal(t){return t}notationToExternal(t){return t}}class Yt{constructor(t,e){this.child=t,this.sw=e}notationToInternal(t){return t.family==="T"&&t.innerLayer===void 0&&t.outerLayer===void 0?new E(new N("FLRv",t.innerLayer,t.outerLayer),t.amount):this.child.notationToInternal(t)}notationToExternal(t){let e=t.family;return e.length>0&&e[e.length-1]==="v"&&(e=e.substring(0,e.length-1)),this.sw.spinmatch(e,"FLUR")?new E(new N("T",t.innerLayer,t.outerLayer),t.amount):this.child.notationToExternal(t)}}class zt{constructor(t,e){this.internalNames=t,this.externalNames=e}convertString(t,e,s){let i="";(t.endsWith("v")||t.endsWith("v"))&&t<="_"&&(i=t.slice(t.length-1),t=t.slice(0,t.length-1));const n=t.toUpperCase();let o=!1;return t!==n&&(o=!0,t=n),t=s.joinByFaceIndices(e.splitByFaceNames(t)),o&&(t=t.toLowerCase()),t+i}convert(t,e,s){const i=t.family,n=this.convertString(i,e,s);return i===n?t:new E(new N(n,t.innerLayer,t.outerLayer),t.amount)}notationToInternal(t){return this.convert(t,this.externalNames,this.internalNames)}notationToExternal(t){return this.convert(t,this.internalNames,this.externalNames)}}class Vt{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer===void 0&&t.outerLayer===void 0){if(Math.abs(t.amount)===1){if(t.family==="R++")return new E(new N("L",3,2),-2*t.amount);if(t.family==="R--")return new E(new N("L",3,2),2*t.amount);if(t.family==="D++")return new E(new N("U",3,2),-2*t.amount);if(t.family==="D--")return new E(new N("U",3,2),2*t.amount);if(t.family==="R_PLUSPLUS_")return new E(new N("L",3,2),-2*t.amount);if(t.family==="D_PLUSPLUS_")return new E(new N("U",3,2),-2*t.amount)}if(t.family==="y")return new E("Uv",t.amount);if(t.family==="x"&&Math.abs(t.amount)===2)return new E("ERv",t.amount/2)}return this.child.notationToInternal(t)}notationToExternal(t){return t.family==="ERv"&&Math.abs(t.amount)===1?new E(new N("x",t.innerLayer,t.outerLayer),t.amount*2):t.family==="ILv"&&Math.abs(t.amount)===1?new E(new N("x",t.innerLayer,t.outerLayer),-t.amount*2):t.family==="Uv"?new E(new N("y",t.innerLayer,t.outerLayer),t.amount):t.family==="Dv"?new E("y",-t.amount):this.child.notationToExternal(t)}}class Xt{constructor(t){this.slices=t}notationToInternal(t){const e=t.family;return t.innerLayer||t.outerLayer||(e==="x"?t=new E("Rv",t.amount):e==="y"?t=new E("Uv",t.amount):e==="z"&&(t=new E("Fv",t.amount)),(this.slices&1)===1&&(e==="E"?t=new E(new N("D",(this.slices+1)/2),t.amount):e==="M"?t=new E(new N("L",(this.slices+1)/2),t.amount):e==="S"&&(t=new E(new N("F",(this.slices+1)/2),t.amount))),this.slices>2&&(e==="e"?t=new E(new N("D",this.slices-1,2),t.amount):e==="m"?t=new E(new N("L",this.slices-1,2),t.amount):e==="s"&&(t=new E(new N("F",this.slices-1,2),t.amount)))),t}notationToExternal(t){const e=t.family;if(!(t.innerLayer||t.outerLayer)){if(e==="Rv")return new E("x",t.amount);if(e==="Uv")return new E("y",t.amount);if(e==="Fv")return new E("z",t.amount);if(e==="Lv")return new E("x",-t.amount);if(e==="Dv")return new E("y",-t.amount);if(e==="Bv")return new E("z",-t.amount)}return t}}const qt={U:"frl",L:"fld",R:"fdr",B:"dlr",u:"FRL",l:"FLD",r:"FDR",b:"DLR",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R"},_t={U:"FRL",L:"FLD",R:"FDR",B:"DLR",u:"frl",l:"fld",r:"fdr",b:"dlr",Uv:"FRLv",Lv:"FLDv",Rv:"FDRv",Bv:"DLRv",D:"D",F:"F",BL:"L",BR:"R",d:"d",f:"f",bl:"l",br:"r"},Dt={U:"FRL",L:"FLD",R:"FDR",B:"DLR"},kt=new N("y"),Et=new N("Dv");class St{constructor(t){w(this,"wcaHack",!1);w(this,"map",qt);this.child=t}notationToInternal(t){if(this.wcaHack&&t.innerLayer===2&&t.outerLayer===null){const s=Dt[t.family];if(s)return new E(new N(s,t.innerLayer,t.outerLayer),t.amount)}const e=this.map[t.family];return e?new E(new N(e,t.innerLayer,t.outerLayer),t.amount):kt.isIdentical(t.quantum)?new E(Et,-t.amount):null}notationToExternal(t){if(this.wcaHack&&t.innerLayer===2&&t.outerLayer===null){for(const[e,s]of Object.entries(Dt))if(this.child.spinmatch(t.family,s))return new E(new N(e,t.innerLayer,t.outerLayer),t.amount)}for(const[e,s]of Object.entries(this.map))if(this.child.spinmatch(t.family,s))return new E(new N(e,t.innerLayer,t.outerLayer),t.amount);return Et.isIdentical(t.quantum)?new E(kt,-t.amount):null}}class te extends St{constructor(e){super(e);w(this,"wcaHack",!0);this.map=_t}}const jt={U:"UBL",UL:"ULF",F:"UFR",UR:"URB",B:"DBL",D:"DFR",L:"DLF",R:"DRB",Uv:"UBLv",ULv:"ULFv",Fv:"UFRv",URv:"URBv",Bv:"DBLv",Dv:"DFRv",Lv:"DLFv",Rv:"DRBv"},wt=new N("x"),Ct=new N("Rv"),ee=new N("Lv"),vt=new N("y"),Ut=new N("Uv"),se=new N("Dv"),yt=new N("z"),$t=new N("Fv"),ie=new N("Bv");class ne{constructor(t){this.child=t}notationToInternal(t){if(t.innerLayer||t.outerLayer)return null;const e=jt[t.family];return e?new E(new N(e,t.outerLayer,t.innerLayer),t.amount):wt.isIdentical(t.quantum)?new E(Ct,t.amount):vt.isIdentical(t.quantum)?new E(Ut,t.amount):yt.isIdentical(t.quantum)?new E($t,t.amount):null}notationToExternal(t){for(const[e,s]of Object.entries(jt))if(this.child.spinmatchv(t.family,s))return new E(new N(e,t.innerLayer,t.outerLayer),t.amount);return Ct.isIdentical(t.quantum)?new E(wt,t.amount):ee.isIdentical(t.quantum)?new E(wt,-t.amount):Ut.isIdentical(t.quantum)?new E(vt,t.amount):se.isIdentical(t.quantum)?new E(vt,-t.amount):$t.isIdentical(t.quantum)?new E(yt,t.amount):ie.isIdentical(t.quantum)?new E(yt,-t.amount):null}}function oe(h,t){const e={...h,moves:{}};for(const[s,i]of Object.entries(h.moves)){let n=s,o="";["v","w"].includes(s.at(-1))&&(n=s.slice(0,-1),o=s.slice(-1));const r=t.notationToExternal(E.fromString(n));if(!r)continue;const b=r+o;if(!b)throw new Error(`Missing external move name for: ${s.toString()}`);e.moves[b.toString()]=i}return e}function Ce(h){let t=0;const e={};for(;t<h.length&&h[t][0]==="-";){const i=h[t++];if(i==="--rotations")e.addRotations=!0;else if(i==="--allmoves")e.allMoves=!0;else if(i==="--outerblockmoves")e.outerBlockMoves=!0;else if(i==="--vertexmoves")e.vertexMoves=!0;else if(i==="--nocorners")e.includeCornerOrbits=!1;else if(i==="--noedges")e.includeEdgeOrbits=!1;else if(i==="--noorientation")e.fixedOrientation=!0;else if(i==="--nocenters")e.includeCenterOrbits=!1;else if(i==="--omit")e.excludeOrbits=h[t].split(","),t++;else if(i==="--moves")e.moveList=h[t].split(","),t++;else if(i==="--optimize")e.optimizeOrbits=!0;else if(i==="--scramble")e.scrambleAmount=100;else if(i==="--fixcorner")e.fixedPieceType="v";else if(i==="--fixedge")e.fixedPieceType="e";else if(i==="--fixcenter")e.fixedPieceType="f";else if(i==="--orientcenters")e.orientCenters=!0;else if(i==="--puzzleorientation")e.puzzleOrientation=JSON.parse(h[t]),t++;else throw new Error(`Bad option: ${i}`)}return{puzzleDescription:Gt(h.slice(t).join(" ")),options:e}}class re{constructor(t={}){w(this,"verbosity",0);w(this,"allMoves",!1);w(this,"outerBlockMoves");w(this,"vertexMoves",!1);w(this,"addRotations",!1);w(this,"moveList",null);w(this,"fixedOrientation",!1);w(this,"fixedPieceType",null);w(this,"orientCenters",!1);w(this,"includeCornerOrbits",!0);w(this,"includeCenterOrbits",!0);w(this,"includeEdgeOrbits",!0);w(this,"excludeOrbits",[]);w(this,"optimizeOrbits",!1);w(this,"grayCorners",!1);w(this,"grayCenters",!1);w(this,"grayEdges",!1);w(this,"puzzleOrientation",null);w(this,"puzzleOrientations",null);w(this,"scrambleAmount",0);Object.assign(this,t)}}const xt=[],Lt=[];function rt(h){if(!xt[h]){const t=Array(h);for(let e=0;e<h;e++)t[e]=0;xt[h]=t}return xt[h]}function nt(h){if(!Lt[h]){const t=Array(h);for(let e=0;e<h;e++)t[e]=e;Lt[h]=t}return Lt[h]}function ae(h){return new tt(nt(h))}function le(h){let t=BigInt(1);for(;h>1;)t*=BigInt(h),h--;return t}function he(h,t){if(h>t){const e=h;h=t,t=e}for(;h>0;){const e=t%h;t=h,h=e}return t}function At(h,t){return h/he(h,t)*t}class tt{constructor(t){w(this,"n");w(this,"p");this.n=t.length,this.p=t}toString(){return`Perm[${this.p.join(" ")}]`}mul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=t.p[this.p[s]];return new tt(e)}rmul(t){const e=Array(this.n);for(let s=0;s<this.n;s++)e[s]=this.p[t.p[s]];return new tt(e)}inv(){const t=Array(this.n);for(let e=0;e<this.n;e++)t[this.p[e]]=e;return new tt(t)}compareTo(t){for(let e=0;e<this.n;e++)if(this.p[e]!==t.p[e])return this.p[e]-t.p[e];return 0}toGap(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const i=new Array;for(let n=this.p[s];!e[n];n=this.p[n])i.push(1+n),e[n]=!0;t.push(`(${i.reverse().join(",")})`)}return t.join("")}toMathematica(){const t=new Array,e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;const i=new Array;for(let n=this.p[s];!e[n];n=this.p[n])i.push(1+n),e[n]=!0;t.push(`{${i.reverse().join(",")}}`)}return`Cycles[{${t.join(",")}}]`}order(){let t=1;const e=new Array(this.n);for(let s=0;s<this.p.length;s++){if(e[s]||this.p[s]===s)continue;let i=0;for(let n=s;!e[n];n=this.p[n])i++,e[n]=!0;t=At(t,i)}return t}}class Mt{constructor(t,e){this.size=t,this.mod=e}reassemblySize(){return le(this.size)*BigInt(this.mod)**BigInt(this.size)}}let ce=0;function ut(h,t){const e=E.fromString(t),s=h.notationToExternal(e);return s===null||e===s?t:s.toString()}class dt{constructor(t,e,s,i,n,o,r){this.orbitnames=t,this.orbitdefs=e,this.solved=s,this.movenames=i,this.moveops=n,this.isRotation=o,this.forcenames=r}toKTransformationData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKTransformationOrbitData();return e}toKPatternData(t){const e={};for(let s=0;s<this.orbitnames.length;s++)e[this.orbitnames[s]]=t.orbits[s].toKPatternOrbitData();return e}static transformToKTransformationData(t,e){const s={};for(let i=0;i<t.length;i++)s[t[i]]=e.orbits[i].toKTransformationOrbitData();return s}describeSet(t,e,s){const i=this.orbitdefs[t].size,n=new Array(i);for(let o=0;o<i;o++)n[o]=[];for(let o=0;o<this.movenames.length;o++){if(this.isRotation[o])continue;let r=this.movenames[o];this.forcenames[o]||(r=ut(s,r),r[r.length-1]==="'"&&(r=r.substring(0,r.length-1)));const b=this.moveops[o].orbits[t];for(let l=0;l<i;l++)(b.perm[l]!==l||b.ori[l]!==0)&&n[l].push(r)}for(let o=0;o<i;o++)e.push(`# ${o+1} ${n[o].join(" ")}`)}toKsolve(t,e=new Nt){const s=[];s.push(`Name ${t}`),s.push("");for(let i=0;i<this.orbitnames.length;i++)s.push(`Set ${this.orbitnames[i]} ${this.orbitdefs[i].size} ${this.orbitdefs[i].mod}`),this.describeSet(i,s,e);s.push(""),s.push("Solved");for(let i=0;i<this.orbitnames.length;i++)this.solved.orbits[i].appendDefinition(s,this.orbitnames[i],!1,!1);s.push("End");for(let i=0;i<this.movenames.length;i++){s.push("");let n=this.movenames[i];this.forcenames[i]||(n=ut(e,this.movenames[i]));let o=!1;n[n.length-1]==="'"&&(o=!0,n=n.substring(0,n.length-1)),s.push(`Move ${n}`);for(let r=0;r<this.orbitnames.length;r++)o?this.moveops[i].orbits[r].inv().appendDefinition(s,this.orbitnames[r],!0):this.moveops[i].orbits[r].appendDefinition(s,this.orbitnames[r],!0);s.push("End")}return s}toKPuzzleDefinition(t){const e=[],s={};for(let n=0;n<this.orbitnames.length;n++){e.push({orbitName:this.orbitnames[n],numPieces:this.orbitdefs[n].size,numOrientations:this.orbitdefs[n].mod});const o=this.solved.orbits[n].toKTransformationOrbitData();s[this.orbitnames[n]]={pieces:o.permutation,orientation:o.orientationDelta}}const i={};if(t)for(let n=0;n<this.movenames.length;n++)i[this.movenames[n]]=this.toKTransformationData(this.moveops[n]);return{name:`PG3D #${++ce}`,orbits:e,defaultPattern:s,moves:i}}optimize(){const t=[],e=[],s=[],i=[];for(let n=0;n<this.moveops.length;n++)i.push([]);for(let n=0;n<this.orbitdefs.length;n++){const o=this.orbitdefs[n].mod,r=this.orbitdefs[n].size,b=new Ot(r),l=new Array(this.orbitdefs[n].size);for(let f=0;f<r;f++)l[f]=!1;for(let f=0;f<this.moveops.length;f++)for(let p=0;p<r;p++)(this.moveops[f].orbits[n].perm[p]!==p||this.moveops[f].orbits[n].ori[p]!==0)&&(this.isRotation[f]||(l[p]=!0),b.union(p,this.moveops[f].orbits[n].perm[p]));let u=!0;if(o>1){u=!1;const f=new Ot(this.orbitdefs[n].size*o);for(let p=0;p<this.moveops.length;p++)for(let a=0;a<r;a++)if(this.moveops[p].orbits[n].perm[a]!==a||this.moveops[p].orbits[n].ori[a]!==0)for(let d=0;d<o;d++)f.union(a*o+d,this.moveops[p].orbits[n].perm[a]*o+(d+this.moveops[p].orbits[n].ori[a])%o);for(let p=0;!u&&p<r;p++)for(let a=1;a<o;a++)f.find(p*o)===f.find(p*o+a)&&(u=!0);for(let p=0;!u&&p<r;p++)for(let a=0;a<p;a++)this.solved.orbits[n].perm[p]===this.solved.orbits[n].perm[a]&&(u=!0)}let v=-1,g=!1;for(let f=0;f<this.orbitdefs[n].size;f++)if(l[f]){const p=b.find(f);v<0?v=p:v!==p&&(g=!0)}for(let f=0;f<this.orbitdefs[n].size;f++){if(!l[f]||b.find(f)!==f)continue;const a=[],d=[];let F=0;for(let y=0;y<this.orbitdefs[n].size;y++)b.find(y)===f&&(a[F]=y,d[y]=F,F++);if(g?t.push(`${this.orbitnames[n]}_p${f}`):t.push(this.orbitnames[n]),u){e.push(new Mt(F,this.orbitdefs[n].mod)),s.push(this.solved.orbits[n].remapVS(a,F));for(let y=0;y<this.moveops.length;y++)i[y].push(this.moveops[y].orbits[n].remap(a,d,F))}else{e.push(new Mt(F,1)),s.push(this.solved.orbits[n].remapVS(a,F).killOri());for(let y=0;y<this.moveops.length;y++)i[y].push(this.moveops[y].orbits[n].remap(a,d,F).killOri())}}}return new dt(t,e,new gt(s),this.movenames,i.map(n=>new at(n)),this.isRotation,this.forcenames)}scramble(t){this.solved=this.solved.mul(this.getScrambleTransformation(t))}getScrambleTransformation(t){t<100&&(t=100);const e=[];for(let i=0;i<this.moveops.length;i++)e[i]=this.moveops[i];for(let i=0;i<e.length;i++){const n=Math.floor(Math.random()*e.length),o=e[i];e[i]=e[n],e[n]=o}t<e.length&&(t=e.length);for(let i=0;i<t;i++){const n=Math.floor(Math.random()*e.length),o=Math.floor(Math.random()*e.length),r=Math.floor(Math.random()*this.moveops.length);e[n]=e[n].mul(e[o]).mul(this.moveops[r]),Math.random()<.1&&(e[n]=e[n].mul(this.moveops[r]))}let s=e[0];for(let i=1;i<e.length;i++)s=s.mul(e[i]);return s}reassemblySize(){let t=BigInt(1);for(let e=0;e<this.orbitdefs.length;e++)t*=this.orbitdefs[e].reassemblySize();return t}}const X=class X{constructor(t,e,s){this.perm=t,this.ori=e,this.orimod=s}static e(t,e){return new X(nt(t),rt(t),e)}mul(t){const e=this.perm.length,s=new Array(e);if(this.orimod===1){for(let i=0;i<e;i++)s[i]=this.perm[t.perm[i]];return new X(s,this.ori,this.orimod)}else{const i=new Array(e);for(let n=0;n<e;n++)s[n]=this.perm[t.perm[n]],i[n]=(this.ori[t.perm[n]]+t.ori[n])%this.orimod;return new X(s,i,this.orimod)}}inv(){const t=this.perm.length,e=new Array(t),s=new Array(t);for(let i=0;i<t;i++)e[this.perm[i]]=i,s[this.perm[i]]=(this.orimod-this.ori[i])%this.orimod;return new X(e,s,this.orimod)}equal(t){const e=this.perm.length;for(let s=0;s<e;s++)if(this.perm[s]!==t.perm[s]||this.ori[s]!==t.ori[s])return!1;return!0}killOri(){const t=this.perm.length;for(let e=0;e<t;e++)this.ori[e]=0;return this.orimod=1,this}toPerm(){const t=this.orimod;if(t===1)return new tt(this.perm);const e=this.perm.length,s=new Array(e*t);for(let i=0;i<e;i++)for(let n=0;n<t;n++)s[i*t+n]=t*this.perm[i]+(this.ori[i]+n)%t;return new tt(s)}identicalPieces(){const t=[],e=this.perm.length,s=[];for(let i=0;i<e;i++){const n=this.perm[i];if(t[n]===void 0){const o=[i];t[n]=!0;for(let r=i+1;r<e;r++)this.perm[r]===n&&o.push(r);s.push(o)}}return s}order(){return this.toPerm().order()}isIdentity(){const t=this.perm.length;if(this.perm===nt(t)&&this.ori===rt(t))return!0;for(let e=0;e<t;e++)if(this.perm[e]!==e||this.ori[e]!==0)return!1;return!0}zeroOris(){const t=this.perm.length;if(this.ori===rt(t))return!0;for(let e=0;e<t;e++)if(this.ori[e]!==0)return!1;return!0}remap(t,e,s){const i=new Array(s),n=new Array(s);for(let o=0;o<s;o++)i[o]=e[this.perm[t[o]]],n[o]=this.ori[t[o]];return new X(i,n,this.orimod)}remapVS(t,e){const s=new Array(e),i=new Array(e);let n=0;const o=[];for(let r=0;r<e;r++){const b=this.perm[t[r]];o[b]===void 0&&(o[b]=n++),s[r]=o[b],i[r]=this.ori[t[r]]}return new X(s,i,this.orimod)}appendDefinition(t,e,s,i=!0){if(!(i&&this.isIdentity())&&(t.push(e),t.push(this.perm.map(n=>n+1).join(" ")),!this.zeroOris()))if(s){const n=new Array(this.ori.length);for(let o=0;o<n.length;o++)n[this.perm[o]]=this.ori[o];t.push(n.join(" "))}else t.push(this.ori.join(" "))}toKTransformationOrbitData(){const t=this.perm.length;return this.isIdentity()?(X.ktransformationCache[t]||(X.ktransformationCache[t]={permutation:nt(t),orientationDelta:rt(t)}),X.ktransformationCache[t]):{permutation:this.perm,orientationDelta:this.ori}}toKPatternOrbitData(){const t=this.perm.length;return{pieces:this.perm,orientation:this.ori,orientationMod:rt(t)}}};w(X,"ktransformationCache",[]);let it=X;class Tt{constructor(t){this.orbits=t}internalMul(t){const e=[];for(let s=0;s<this.orbits.length;s++)e.push(this.orbits[s].mul(t.orbits[s]));return e}internalInv(){const t=[];for(const e of this.orbits)t.push(e.inv());return t}equal(t){for(let e=0;e<this.orbits.length;e++)if(!this.orbits[e].equal(t.orbits[e]))return!1;return!0}killOri(){for(const t of this.orbits)t.killOri();return this}toPerm(){const t=new Array;let e=0;for(const i of this.orbits){const n=i.toPerm();t.push(n),e+=n.n}const s=new Array(e);e=0;for(const i of t){for(let n=0;n<i.n;n++)s[e+n]=e+i.p[n];e+=i.n}return new tt(s)}identicalPieces(){const t=[];let e=0;for(const s of this.orbits){const i=s.orimod,n=s.identicalPieces();for(let o=0;o<n.length;o++)t.push(n[o].map(r=>r*i+e));e+=i*s.perm.length}return t}order(){let t=1;for(const e of this.orbits)t=At(t,e.order());return t}}class at extends Tt{mul(t){return new at(this.internalMul(t))}mulScalar(t){if(t===0)return this.e();let e=this;for(t<0&&(e=e.inv(),t=-t);!(t&1);)e=e.mul(e),t>>=1;if(t===1)return e;let s=e,i=this.e();for(;t>0;)t&1&&(i=i.mul(s)),t>1&&(s=s.mul(s)),t>>=1;return i}inv(){return new at(this.internalInv())}e(){return new at(this.orbits.map(t=>it.e(t.perm.length,t.orimod)))}}class gt extends Tt{mul(t){return new gt(this.internalMul(t))}}class Ot{constructor(t){w(this,"heads");this.n=t,this.heads=new Array(t);for(let e=0;e<t;e++)this.heads[e]=e}find(t){let e=this.heads[t];return this.heads[e]===e||(e=this.find(this.heads[e]),this.heads[t]=e),e}union(t,e){const s=this.find(t),i=this.find(e);s<i?this.heads[i]=s:s>i&&(this.heads[s]=i)}}function fe(h,t){const e=h.moveops.length;if(e>30)throw new Error("Canon info too big for bitmask");const s=[],i=[];for(let o=0;o<e;o++){const r=h.moveops[o];s.push(r.order());let b=0;for(let l=0;l<e;l++){if(l===o)continue;const u=h.moveops[l];r.mul(u).equal(u.mul(r))&&(b|=1<<l)}i.push(b)}let n={};n[0]=1;for(let o=0;o<100;o++){let r=0;const b={};let l=0;for(const u in n){const v=+u,g=n[v];r+=g,l++;for(let f=0;f<s.length;f++)if(!(v>>f&1)&&!(v&i[f]&(1<<f)-1)){const p=v&i[f]|1<<f;b[p]===void 0&&(b[p]=0),b[p]+=(s[f]-1)*g}}t(`${o}: canonseq ${r} states ${l}`),n=b}}const Rt={"2x2x2":"c f 0","3x3x3":"c f 0.333333333333333","4x4x4":"c f 0.5 f 0","5x5x5":"c f 0.6 f 0.2","6x6x6":"c f 0.666666666666667 f 0.333333333333333 f 0","7x7x7":"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143","8x8x8":"c f 0.75 f 0.5 f 0.25 f 0","9x9x9":"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111","10x10x10":"c f 0.8 f 0.6 f 0.4 f 0.2 f 0","11x11x11":"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909","12x12x12":"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0","13x13x13":"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769","20x20x20":"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9","30x30x30":"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333","40x40x40":"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",skewb:"c v 0","master skewb":"c v 0.275","professor skewb":"c v 0 v 0.38","compy cube":"c v 0.915641442663986",helicopter:"c e 0.707106781186547","curvy copter":"c e 0.83",dino:"c v 0.577350269189626","little chop":"c e 0",pyramorphix:"t e 0",mastermorphix:"t e 0.346184634065199",pyraminx:"t v 0.333333333333333 v 1.66666666666667",tetraminx:"t v 0.333333333333333","master pyraminx":"t v 0 v 1 v 2","master tetraminx":"t v 0 v 1","professor pyraminx":"t v -0.2 v 0.6 v 1.4 v 2.2","professor tetraminx":"t v -0.2 v 0.6 v 1.4","royal pyraminx":"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667 v 2.33333333333333","royal tetraminx":"t v -0.333333333333333 v 0.333333333333333 v 1 v 1.66666666666667","emperor pyraminx":"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286 v 2.42857142857143","emperor tetraminx":"t v -0.428571428571429 v 0.142857142857143 v 0.714285714285714 v 1.28571428571429 v 1.85714285714286","Jing pyraminx":"t f 0","master pyramorphix":"t e 0.866025403784437",megaminx:"d f 0.7",gigaminx:"d f 0.64 f 0.82",teraminx:"d f 0.64 f 0.76 f 0.88",petaminx:"d f 0.64 f 0.73 f 0.82 f 0.91",examinx:"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",zetaminx:"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",yottaminx:"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",pentultimate:"d f 0","master pentultimate":"d f 0.1","elite pentultimate":"d f 0 f 0.145905",starminx:"d v 0.937962370425399","starminx 2":"d f 0.23606797749979","pyraminx crystal":"d f 0.447213595499989",chopasaurus:"d v 0","big chop":"d e 0","skewb diamond":"o f 0",FTO:"o f 0.333333333333333","master FTO":"o f 0.5 f 0","Christopher's jewel":"o v 0.577350269189626",octastar:"o e 0","Trajber's octahedron":"o v 0.433012701892219","radio chop":"i f 0",icosamate:"i v 0","Regular Astrominx":"i v 0.18759247376021","Regular Astrominx + Big Chop":"i v 0.18759247376021 e 0",Redicosahedron:"i v 0.794654472291766","Redicosahedron with centers":"i v 0.84",Icosaminx:"i v 0.73","Eitan's star":"i f 0.61803398874989","2x2x2 + dino":"c f 0 v 0.577350269189626","2x2x2 + little chop":"c f 0 e 0","dino + little chop":"c v 0.577350269189626 e 0","2x2x2 + dino + little chop":"c f 0 v 0.577350269189626 e 0","megaminx + chopasaurus":"d f 0.61803398875 v 0","starminx combo":"d f 0.23606797749979 v 0.937962370425399"},ot=1e-9;function Bt(h){let t=new O(0,0,0,0);for(let e=0;e<h.length;e++)t=t.sum(h[e]);return t.smul(1/h.length)}function ue(h,t,e,s){const i=s[h].intersect3(s[t],s[e]);if(!i)return i;for(let n=0;n<s.length;n++)if(n!==h&&n!==t&&n!==e){const o=s[n].b*i.b+s[n].c*i.c+s[n].d*i.d;if(s[n].a>0&&o>s[n].a||s[n].a<0&&o<s[n].a)return!1}return i}class O{constructor(t,e,s,i){this.a=t,this.b=e,this.c=s,this.d=i}mul(t){return new O(this.a*t.a-this.b*t.b-this.c*t.c-this.d*t.d,this.a*t.b+this.b*t.a+this.c*t.d-this.d*t.c,this.a*t.c-this.b*t.d+this.c*t.a+this.d*t.b,this.a*t.d+this.b*t.c-this.c*t.b+this.d*t.a)}toString(){return`Q[${this.a},${this.b},${this.c},${this.d}]`}dist(t){return Math.hypot(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}len(){return Math.hypot(this.a,this.b,this.c,this.d)}cross(t){return new O(0,this.c*t.d-this.d*t.c,this.d*t.b-this.b*t.d,this.b*t.c-this.c*t.b)}dot(t){return this.b*t.b+this.c*t.c+this.d*t.d}normalize(){const t=Math.sqrt(this.dot(this));return new O(this.a/t,this.b/t,this.c/t,this.d/t)}makenormal(){return new O(0,this.b,this.c,this.d).normalize()}normalizeplane(){const t=Math.hypot(this.b,this.c,this.d);return new O(this.a/t,this.b/t,this.c/t,this.d/t)}smul(t){return new O(this.a*t,this.b*t,this.c*t,this.d*t)}sum(t){return new O(this.a+t.a,this.b+t.b,this.c+t.c,this.d+t.d)}sub(t){return new O(this.a-t.a,this.b-t.b,this.c-t.c,this.d-t.d)}angle(){return 2*Math.acos(this.a)}invrot(){return new O(this.a,-this.b,-this.c,-this.d)}det3x3(t,e,s,i,n,o,r,b,l){return t*(n*l-o*b)+e*(o*r-i*l)+s*(i*b-n*r)}rotateplane(t){const e=t.mul(new O(0,this.b,this.c,this.d)).mul(t.invrot());return e.a=this.a,e}orthogonal(){const t=Math.abs(this.b),e=Math.abs(this.c),s=Math.abs(this.d);return t<e&&t<s?this.cross(new O(0,1,0,0)).normalize():e<t&&e<s?this.cross(new O(0,0,1,0)).normalize():this.cross(new O(0,0,0,1)).normalize()}pointrotation(t){const e=this.normalize();if(t=t.normalize(),e.sub(t).len()<ot)return new O(1,0,0,0);let s=e.sum(t);s.len()<ot?s=s.orthogonal():s=s.normalize();const i=e.cross(s);return i.a=e.dot(s),i}unproject(t){return this.sum(t.smul(-this.dot(t)/(this.len()*t.len())))}rotatepoint(t){return t.mul(this).mul(t.invrot())}rotateface(t){return t.map(e=>e.rotatepoint(this))}intersect3(t,e){const s=this.det3x3(this.b,this.c,this.d,t.b,t.c,t.d,e.b,e.c,e.d);return Math.abs(s)<ot?!1:new O(0,this.det3x3(this.a,this.c,this.d,t.a,t.c,t.d,e.a,e.c,e.d)/s,this.det3x3(this.b,this.a,this.d,t.b,t.a,t.d,e.b,e.a,e.d)/s,this.det3x3(this.b,this.c,this.a,t.b,t.c,t.a,e.b,e.c,e.a)/s)}side(t){return t>ot?1:t<-ot?-1:0}cutface(t){const e=this.a;let s=0,i=null;for(let n=0;n<t.length;n++)s|=1<<this.side(t[n].dot(this)-e)+1;if((s&5)===5){i=[];const n=t.map(o=>this.side(o.dot(this)-e));for(let o=-1;o<=1;o+=2){const r=[];for(let b=0;b<t.length;b++){(n[b]===o||n[b]===0)&&r.push(t[b]);const l=(b+1)%t.length;if(n[b]+n[l]===0&&n[b]!==0){const u=t[b].dot(this)-e,v=t[l].dot(this)-e,g=u/(u-v),f=t[b].smul(1-g).sum(t[l].smul(g));r.push(f)}}i.push(r)}}return i}cutfaces(t){const e=[];for(let s=0;s<t.length;s++){const i=t[s],n=this.cutface(i);n?(e.push(n[0]),e.push(n[1])):e.push(i)}return e}faceside(t){const e=this.a;for(let s=0;s<t.length;s++){const i=this.side(t[s].dot(this)-e);if(i!==0)return i}throw new Error("Could not determine side of plane in faceside")}sameplane(t){const e=this.normalize(),s=t.normalize();return e.dist(s)<ot||e.dist(s.smul(-1))<ot}makecut(t){return new O(t,this.b,this.c,this.d)}}const mt=1e-9;function me(){const h=Math.sqrt(.5);return[new O(h,h,0,0),new O(h,0,h,0)]}function pe(){return[new O(.5,.5,.5,.5),new O(.5,.5,.5,-.5)]}function de(){const h=2*Math.PI/10;let t=.5+.3*Math.sqrt(5),e=.5+.1*Math.sqrt(5);const s=Math.sqrt(t*t+e*e);return t/=s,e/=s,[new O(Math.cos(h),t*Math.sin(h),e*Math.sin(h),0),new O(.5,.5,.5,.5)]}function ge(){let h=.16666666666666666+Math.sqrt(5)/6,t=2/3+Math.sqrt(5)/3;const e=Math.sqrt(h*h+t*t);h/=e,t/=e;const s=2*Math.PI/6;return[new O(Math.cos(s),h*Math.sin(s),t*Math.sin(s),0),new O(Math.cos(s),-h*Math.sin(s),t*Math.sin(s),0)]}function be(){const h=Math.sqrt(.5);return[new O(.5,.5,.5,.5),new O(h,0,0,h)]}function we(h){const t=[new O(1,0,0,0)];for(let e=0;e<t.length;e++)for(let s=0;s<h.length;s++){const i=h[s].mul(t[e]),n=i.smul(-1);let o=!1;for(let r=0;r<t.length;r++)if(i.dist(t[r])<mt||n.dist(t[r])<mt){o=!0;break}o||t.push(i)}return t}function Pt(h,t){const e=[],s=[];for(let i=0;i<t.length;i++){const n=h.rotateplane(t[i]);let o=!1;for(let r=0;r<e.length;r++)if(n.dist(e[r])<mt){o=!0;break}o||(e.push(n),s.push(t[i]))}return s}function It(h){const t=[];for(let e=1;e<h.length;e++)for(let s=e+1;s<h.length;s++){const i=ue(0,e,s,h);if(i){let n=!1;for(let o=0;o<t.length;o++)if(i.dist(t[o])<mt){n=!0;break}n||t.push(i)}}for(;;){let e=!1;for(let s=0;s<t.length;s++){const i=(s+1)%t.length;if(h[0].dot(t[s].cross(t[i]))<0){const n=t[s];t[s]=t[i],t[i]=n,e=!0}}if(!e)break}return t}class ve{constructor(){w(this,"mult");this.mult=[]}multiply(t){for(let e=2;e*e<=t;e++)for(;t%e===0;)this.mult[e]!==void 0?this.mult[e]++:this.mult[e]=1,t/=e;t>1&&(this.mult[t]!==void 0?this.mult[t]++:this.mult[t]=1)}toString(){let t="";for(let e=0;e<this.mult.length;e++)this.mult[e]!==void 0&&(t!==""&&(t+="*"),t+=e,this.mult[e]>1&&(t+=`^${this.mult[e]}`));return t}}function ye(h,t){const e=h[0].p.length,s=ae(e);let i=[],n=[],o=[],r=[],b=[];function l(f){for(let p=f.p.length-1;p>=0;p--){const a=f.p[p];if(a!==p){if(!i[p][a])return!1;f=f.mul(n[p][a])}}return!0}function u(f,p,a){r[f].push(p),b[f].push(a);for(let d=0;d<i[f].length;d++)i[f][d]&&v(f,i[f][d].mul(p),a+o[f][d])}function v(f,p,a){const d=p.p[f];if(!i[f][d]){i[f][d]=p,n[f][d]=p.inv(),o[f][d]=a;for(let y=0;y<r[f].length;y++)v(f,p.mul(r[f][y]),a+b[f][y]);return}const F=p.mul(n[f][d]);l(F)||u(f-1,F,a+o[f][d])}function g(){i=[],n=[],r=[],o=[],b=[];for(let a=0;a<e;a++)i.push([]),n.push([]),o.push([]),r.push([]),b.push([]),i[a][a]=s,n[a][a]=s,o[a][a]=0;let f=0,p=BigInt(1);for(let a=0;a<h.length;a++){u(e-1,h[a],1),p=BigInt(1);let d=0,F=0;const y=new ve;for(let x=0;x<e;x++){let R=0,D=0;for(let H=0;H<e;H++)i[x][H]&&(R++,D+=o[x][H],x!==H&&f++);d+=r[x].length,p*=BigInt(R),R>1&&y.multiply(R);const S=D/R;F+=S}t(`${a}: sz ${p} T ${d} sol ${F} none ${f} mults ${y.toString()}`)}return p}return g()}class lt{constructor(t){w(this,"coords");w(this,"length");this.coords=new Array(t.length*3);for(let e=0;e<t.length;e++)this.coords[3*e]=t[e].b,this.coords[3*e+1]=t[e].c,this.coords[3*e+2]=t[e].d;this.length=t.length}get(t){return new O(0,this.coords[3*t],this.coords[3*t+1],this.coords[3*t+2])}centermass(){let t=0,e=0,s=0;for(let i=0;i<this.length;i++)t+=this.coords[3*i],e+=this.coords[3*i+1],s+=this.coords[3*i+2];return new O(0,t/this.length,e/this.length,s/this.length)}rotate(t){const e=[];for(let s=0;s<this.length;s++)e.push(this.get(s).rotatepoint(t));return new lt(e)}rotateforward(){const t=[];for(let e=1;e<this.length;e++)t.push(this.get(e));return t.push(this.get(0)),new lt(t)}}class pt{constructor(t,e,s){this.face=t,this.left=e,this.right=s}split(t){var s,i;const e=t.cutface(this.face);return e!==null&&(this.left===void 0?(this.left=new pt(e[0]),this.right=new pt(e[1])):(this.left=(s=this.left)==null?void 0:s.split(t),this.right=(i=this.right)==null?void 0:i.split(t))),this}collect(t,e){var s,i,n,o;return this.left===void 0?t.push(new lt(this.face)):e?((s=this.left)==null||s.collect(t,!1),(i=this.right)==null||i.collect(t,!0)):((n=this.right)==null||n.collect(t,!1),(o=this.left)==null||o.collect(t,!0)),t}}function xe(h,t){const e=[];for(const s of h)for(const i of t)e.push(i.rotate(s));return e}const Z=1e-9,Le="PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.";function Be(){return{4:[["F","D","L","R"]],6:[["F","D","L","U","R"],["R","F","","B",""]],8:[["F","D","L","R"],["D","F","BR",""],["BR","D","","BB"],["BB","BR","U","BL"]],12:[["U","F","","","",""],["F","U","R","C","A","L"],["R","F","","","E",""],["E","R","","BF","",""],["BF","E","BR","BL","I","D"]],20:[["R","C","F","E"],["F","R","L","U"],["L","F","A",""],["E","R","G","I"],["I","E","S","H"],["S","I","J","B"],["B","S","K","D"],["K","B","M","O"],["O","K","P","N"],["P","O","Q",""]]}}const Fe={4:{v:["DFR","DLF","DRL","FLR"],e:["FR","LF","DF","DL","RD","RL"],c:["DF","FD","RL","LR"]},6:{v:["URF","UBR","ULB","UFL","DFR","DRB","DBL","DLF"],e:["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],c:["UB","LU","FU","RU","BU","DF"]},8:{v:["UBBBRR","URFL","ULBLBB","DBRBBBL","DBLLF","DFRBR"],e:["UL","UBB","UR","BRD","BLD","FD","BRR","FR","FL","BLL","BLBB","BRBB"],c:["BBU","LU","RU","BRD","FD","BLD","DF","UBB"]},12:{v:["URF","UFL","ULBL","UBLBR","UBRR","DEBF","DBFI","DIA","DAC","DCE","LAI","ALF","FCA","CFR","REC","ERBR","BRBFE","BFBRBL","BLIBF","IBLL"],e:["UF","UR","UBR","UBL","UL","ER","EBR","EBF","ED","EC","IBF","IBL","IL","IA","ID","AC","CF","FA","BFBR","BRBL","BLBF","CD","AD","AL","FL","FR","CR","BFD","BRR","BLL"],c:["UF","FU","DBF","BFD","AD","CD","BRU","BLU","LA","RA","EBR","IBL"]},20:{v:["FLPQU","FUGER","FRCAL","HCREI","ISBDH","JSIEG","BSJMK","MQPOK","ONDBK","NOPLA","UQMJG","DNACH"],e:["FU","FL","FR","EG","ER","EI","SJ","SI","SB","KM","KB","KO","PQ","PO","PL","UG","JG","MQ","UQ","HC","HD","ND","NA","JM","CA","AL","CR","HI","DB","NO"],c:["FU","UF","GE","EG","JS","SJ","MK","KM","QP","PQ","LA","AL","RC","CR","IH","HI","BD","DB","ON","NO"]}};function Me(){return{4:[["FLR",[0,1,0]],["F",[0,0,1]]],6:[["U",[0,1,0]],["F",[0,0,1]]],8:[["U",[0,1,0]],["F",[0,0,1]]],12:[["U",[0,1,0]],["F",[0,0,1]]],20:[["GUQMJ",[0,1,0]],["F",[0,0,1]]]}}function ct(h,t){for(let e=0;e<h.length;e++)if(h[e][0].dist(t)<Z)return e;throw new Error("Element not found")}function Ue(){return Rt}function $e(h){return Rt[h]}const Oe=["c","t","o","d","i"],Pe=["f","v","e"];function Gt(h){const t=h.split(/ /).filter(Boolean);if(t.length%2===0)return null;const e=t[0];if(e!=="o"&&e!=="c"&&e!=="i"&&e!=="d"&&e!=="t")return null;const s=[];for(let i=1;i<t.length;i+=2){if(t[i]!=="f"&&t[i]!=="v"&&t[i]!=="e")return null;s.push({cutType:t[i],distance:parseFloat(t[i+1])})}return{shape:e,cuts:s}}function Re(h,t={}){const e=Gt(h);if(e===null)throw new Error("Could not parse the puzzle description");const s=new ke(e,Object.assign({},{allMoves:!0},t));return s.allstickers(),s.genperms(),s}function Ie(h,t){return Re(Rt[h],t)}function ze(h,t,e){let s=!1;e-t[1]<t[0]&&(h=[h[2],h[3],h[0],h[1]],t=[e-t[1],e-t[0]],s=!0);let i=h[0],n="";if(t[0]===0&&t[1]===e)i=`${i}v`;else if(t[0]===t[1])t[1]>0&&(n=String(t[1]+1));else if(t[0]===0)i=i.toLowerCase(),t[1]>1&&(n=String(t[1]+1));else throw new Error(`We only support slice and outer block moves right now. ${t}`);return[n+i,s]}function De(h,t){const e=[];let s=0;for(;s<h.length;){s>0&&s<h.length&&h[s]==="_"&&s++;let i="";for(const n of t)h.substr(s).startsWith(n[1])&&n[1].length>i.length&&(i=n[1]);if(i!=="")e.push(i),s+=i.length;else throw new Error(`Could not split ${h} into face names.`)}return e}function ft(h,t){return[h.b/t,-h.c/t,h.d/t]}function Ft(h,t){const e=[],s=h.length;for(let i=0;i<s;i++){const n=ft(h.get(s-i-1),t);e[3*i]=n[0],e[3*i+1]=n[1],e[3*i+2]=n[2]}return e}class ke{constructor(t,e){w(this,"rotations");w(this,"baseplanerot");w(this,"baseplanes");w(this,"facenames");w(this,"faceplanes");w(this,"edgenames");w(this,"vertexnames");w(this,"geonormals");w(this,"moveplanes");w(this,"moveplanes2");w(this,"moveplanesets");w(this,"moveplanenormals");w(this,"movesetorders");w(this,"movesetgeos");w(this,"basefaces");w(this,"faces");w(this,"facecentermass");w(this,"baseFaceCount");w(this,"stickersperface");w(this,"shortedge");w(this,"markedface");w(this,"cubies");w(this,"vertexdistance");w(this,"edgedistance");w(this,"facetocubie");w(this,"facetoord");w(this,"moverotations");w(this,"facelisthash");w(this,"cubiesetnames");w(this,"cubieords");w(this,"cubiesetnums");w(this,"cubieordnums");w(this,"orbitoris");w(this,"cubievaluemap");w(this,"cubiesetcubies");w(this,"cmovesbyslice",[]);w(this,"parsedmovelist");w(this,"duplicatedFaces",[]);w(this,"duplicatedCubies",[]);w(this,"fixedCubie",-1);w(this,"net",[]);w(this,"colors",[]);w(this,"swizzler");w(this,"notationMapper",new Nt);w(this,"addNotationMapper","");w(this,"setReidOrder",!1);w(this,"options");this.puzzleDescription=t,this.options=new re(e),this.options.verbosity>0&&console.log(this.header("# ")),this.create(t)}create(t){const{shape:e,cuts:s}=t;this.moveplanes=[],this.moveplanes2=[],this.faces=[],this.cubies=[];let i=null;switch(e){case"c":{i=me();break}case"o":{i=be();break}case"i":{i=ge();break}case"t":{i=pe();break}case"d":{i=de();break}default:throw new Error(`Bad shape argument: ${e}`)}this.rotations=we(i),this.options.verbosity&&console.log(`# Rotations: ${this.rotations.length}`);const n=i[0];this.baseplanerot=Pt(n,this.rotations);const o=this.baseplanerot.map(c=>n.rotateplane(c));this.baseplanes=o,this.baseFaceCount=o.length;const r=Be()[o.length];this.net=r,this.colors=Qt()[o.length],this.options.verbosity>0&&console.log(`# Base planes: ${o.length}`);const b=It(o),l=new O(0,0,0,0);this.options.verbosity>0&&console.log(`# Face vertices: ${b.length}`);const u=o[0].makenormal(),v=b[0].sum(b[1]).makenormal(),g=b[0].makenormal(),f=new O(1,u.b,u.c,u.d);this.options.verbosity>0&&console.log(`# Boundary is ${f}`);const a=Pt(f,this.rotations).map(c=>f.rotateplane(c)),d=It(a);this.edgedistance=d[0].sum(d[1]).smul(.5).dist(l),this.vertexdistance=d[0].dist(l);const F=[],y=[];let x=!1,R=!1,D=!1;for(const c of s){let L=null,U=0;switch(c.cutType){case"f":{L=u,U=1,x=!0;break}case"v":{L=g,U=this.vertexdistance,D=!0;break}case"e":{L=v,U=this.edgedistance,R=!0;break}default:throw new Error(`Bad cut argument: ${c.cutType}`)}F.push(L.makecut(c.distance)),y.push(c.distance<U)}this.options.addRotations&&(x||F.push(u.makecut(10)),D||F.push(g.makecut(10)),R||F.push(v.makecut(10))),this.basefaces=[];for(const c of this.baseplanerot){const L=c.rotateface(d);this.basefaces.push(new lt(L))}const S=[],H=[],G=[],m=[],M=d.length;function $(c,L,U){for(const k of c)if(k[0].dist(L)<Z){k.push(U);return}c.push([L,U])}for(let c=0;c<this.baseplanerot.length;c++){const L=this.baseplanerot[c].rotateface(d);for(let U=0;U<L.length;U++){const k=(U+1)%L.length,I=L[U].sum(L[k]).smul(.5);$(m,I,c)}}const j=[];for(let c=0;c<this.baseplanerot.length;c++){const L=this.baseplanerot[c].rotateface(d),U=[];for(let k=0;k<L.length;k++){const I=(k+1)%L.length,T=L[k].sum(L[I]).smul(.5),J=m[ct(m,T)];if(c===J[1])U.push(J[2]);else if(c===J[2])U.push(J[1]);else throw new Error("Could not find edge")}j.push(U)}const B={},z=[];z.push(r[0][0]),B[r[0][0]]=0,z[j[0][0]]=r[0][1],B[r[0][1]]=j[0][0];for(const c of r){const L=c[0],U=B[L];if(U===void 0)throw new Error("Bad edge description; first edge not connected");let k=-1;for(let I=0;I<j[U].length;I++){const T=z[j[U][I]];if(T!==void 0&&T===c[1]){k=I;break}}if(k<0)throw new Error("First element of a net not known");for(let I=2;I<c.length;I++){if(c[I]==="")continue;const T=j[U][(I+k-1)%M],J=z[T];if(J!==void 0&&J!==c[I])throw new Error("Face mismatch in net");z[T]=c[I],B[c[I]]=T}}for(let c=0;c<this.baseplanerot.length;c++){const L=this.baseplanerot[c].rotateface(d),U=f.rotateplane(this.baseplanerot[c]),k=z[c];S.push([L,k]),H.push([U,k])}for(let c=0;c<this.baseplanerot.length;c++){const L=this.baseplanerot[c].rotateface(d),U=z[c];for(let k=0;k<L.length;k++){const I=(k+1)%L.length,T=L[k].sum(L[I]).smul(.5),J=(k+2)%L.length,Kt=L[I].sum(L[J]).smul(.5),Ht=ct(m,T),Zt=ct(m,Kt);$(G,L[I],[U,Zt,Ht])}}this.swizzler=new bt(S.map(c=>c[1]));const C=this.swizzler.prefixFree?"":"_",A=Fe[this.baseFaceCount],P=[];for(let c=0;c<this.baseFaceCount;c++)P[1<<c]=c;{const c=A.v;for(const L of c){const U=this.swizzler.splitByFaceNames(L);let k=0;for(const I of U)k|=1<<I;P[k]=U[0]}}{const c=A.e;for(const L of c){const U=this.swizzler.splitByFaceNames(L);let k=0;for(const I of U)k|=1<<I;P[k]=U[0]}}{const c=A.c;for(const L of c){const U=this.swizzler.splitByFaceNames(L),k=1<<U[0]|1<<this.baseFaceCount;P[k]=U[1]}}for(let c=0;c<m.length;c++){if(m[c].length!==3)throw new Error(`Bad length in edge names ${m[c]}`);const L=m[c][1],U=m[c][2];let k=z[L];const I=z[U],T=1<<L|1<<U;P[T]===L?k=k+C+I:k=I+C+k,m[c]=[m[c][0],k]}for(let c=0;c<G.length;c++){let L=0;if(G[c].length<4)throw new Error("Bad length in vertex names");for(let T=1;T<G[c].length;T++)L|=1<<B[G[c][T][0]];const U=P[L];let k=-1;for(let T=1;T<G[c].length;T++)U===B[G[c][T][0]]&&(k=T);if(k<0)throw new Error("Internal error; couldn't find face name when fixing corners");let I="";for(let T=1;T<G[c].length;T++){T===1?I=G[c][k][0]:I=I+C+G[c][k][0];for(let J=1;J<G[c].length;J++)if(G[c][k][1]===G[c][J][2]){k=J;break}}G[c]=[G[c][0],I]}this.markedface=P,this.options.verbosity>1&&(console.log(`# Face names: ${S.map(c=>c[1]).join(" ")}`),console.log(`# Edge names: ${m.map(c=>c[1]).join(" ")}`),console.log(`# Vertex names: ${G.map(c=>c[1]).join(" ")}`));const K=[];for(const c of H)K.push([c[0].makenormal(),c[1],"f"]);for(const c of m)K.push([c[0].makenormal(),c[1],"e"]);for(const c of G)K.push([c[0].makenormal(),c[1],"v"]);this.facenames=S,this.faceplanes=H,this.edgenames=m,this.vertexnames=G,this.geonormals=K;const V=K.map(c=>c[1]);this.swizzler.setGripNames(V),this.options.verbosity>0&&console.log(`# Distances: face 1 edge ${this.edgedistance} vertex ${this.vertexdistance}`);for(let c=0;c<F.length;c++)for(const L of this.rotations){const U=F[c].rotateplane(L);let k=!1;for(const I of this.moveplanes)if(U.sameplane(I)){k=!0;break}k||(this.moveplanes.push(U),y[c]&&this.moveplanes2.push(U))}let Q=new pt(d);const q=this.moveplanes2.slice();let _=31;for(let c=0;c<q.length;c++){const L=c+Math.floor((q.length-c)*(_/65536));Q=Q.split(q[L]),q[L]=q[c],_=(_*1657+101)%65536}const Y=Q.collect([],!0);this.faces=Y,this.options.verbosity>0&&console.log(`# Faces is now ${Y.length}`),this.stickersperface=Y.length;const ht=[],et=Bt(d);for(const c of this.rotations){const L=c.rotateface(d);et.dist(Bt(L))<Z&&ht.push(c)}const st=new Array(Y.length),W=[];for(let c=0;c<Y.length;c++){const L=Y[c].centermass();W.push([et.dist(L),L,c])}W.sort((c,L)=>c[0]-L[0]);for(let c=0;c<Y.length;c++){const L=W[c][2];if(!st[L]){st[L]=!0;for(const U of ht){const k=Y[L].rotate(U),I=k.centermass();for(let T=c+1;T<Y.length&&!(W[T][0]-W[c][0]>Z);T++){const J=W[T][2];if(!st[J]&&I.dist(W[T][1])<Z){st[J]=!0,Y[J]=k;break}}}}}this.shortedge=1e99;for(const c of Y)for(let L=0;L<c.length;L++){const U=(L+1)%c.length,k=c.get(L).dist(c.get(U));k<this.shortedge&&(this.shortedge=k)}this.options.verbosity>0&&console.log(`# Short edge is ${this.shortedge}`),e==="c"&&x&&!R&&!D&&(this.addNotationMapper="NxNxNCubeMapper",this.setReidOrder=!0),e==="c"&&D&&!x&&!R&&(this.addNotationMapper="SkewbMapper"),e==="t"&&(D||x)&&!R&&(this.addNotationMapper="PyraminxOrTetraminxMapper"),e==="o"&&x&&(this.notationMapper=new zt(this.swizzler,new bt(["F","D","L","BL","R","U","BR","B"])),R||D||(this.addNotationMapper="FTOMapper")),e==="d"&&x&&(this.addNotationMapper="MegaminxMapper",this.notationMapper=new zt(this.swizzler,new bt(["U","F","L","BL","BR","R","FR","FL","DL","B","DR","D"])))}keyface(t){return this.keyface2(t.centermass())}keyface2(t){let e="";const s=String.fromCharCode;for(const i of this.moveplanesets)if(i.length>0){const n=t.dot(i[0]);let o=0,r=1;for(;r*2<=i.length;)r*=2;for(;r>0;r>>=1)o+r<=i.length&&n>i[o+r-1].a&&(o+=r);if(o<47)e=e+s(33+o);else if(o<47+47*47)e=e+s(80+Math.floor(o/47)-1)+s(33+o%47);else if(o<47+47*47+47*47*47)e=e+s(80+Math.floor((o-47)/(47*47)-1))+s(80+Math.floor((o-47)/47)%47)+s(33+o%47);else throw Error("Too many slices for cubie encoding")}return e}keyface3(t){const e=t.centermass(),s=[];for(const i of this.moveplanesets)if(i.length>0){const n=e.dot(i[0]);let o=0,r=1;for(;r*2<=i.length;)r*=2;for(;r>0;r>>=1)o+r<=i.length&&n>i[o+r-1].a&&(o+=r);s.push(o)}return s}findface(t){const e=this.keyface2(t),s=this.facelisthash.get(e);if(s.length===1)return s[0];for(let i=0;i+1<s.length;i++){const n=this.facelisthash.get(e)[i];if(Math.abs(t.dist(this.facecentermass[n]))<Z)return n}return s[s.length-1]}project2d(t,e,s){const i=this.facenames[t][0],n=(e+1)%i.length,o=this.baseplanes[t];let r=i[n].sub(i[e]);const b=r.len();r=r.normalize();const l=r.cross(o).normalize();let u=s[1].sub(s[0]);const v=u.len()/b;u=u.normalize();const g=u.b,f=u.c,p=r.smul(g).sub(l.smul(f)).smul(v),a=l.smul(g).sum(r.smul(f)).smul(v),d=new O(0,s[0].b-p.dot(i[e]),s[0].c-a.dot(i[e]),0);return[p,a,d]}allstickers(){this.faces=xe(this.baseplanerot,this.faces),this.options.verbosity>0&&console.log(`# Total stickers is now ${this.faces.length}`),this.facecentermass=new Array(this.faces.length);for(let m=0;m<this.faces.length;m++)this.facecentermass[m]=this.faces[m].centermass();const t=[],e=[];for(const m of this.moveplanes){const M=m.makenormal();let $=!1;for(const j of e)M.sameplane(j.makenormal())&&($=!0);$||(e.push(M),t.push([]))}for(const m of this.moveplanes2){const M=m.makenormal();for(let $=0;$<e.length;$++)if(M.sameplane(e[$])){t[$].push(m);break}}for(let m=0;m<t.length;m++){const M=t[m].map(j=>j.normalizeplane()),$=e[m];for(let j=0;j<M.length;j++)M[j].makenormal().dist($)>Z&&(M[j]=M[j].smul(-1));M.sort((j,B)=>j.a-B.a),t[m]=M}this.moveplanesets=t,this.moveplanenormals=e;const s=t.map(m=>m.length);this.options.verbosity>0&&console.log(`# Move plane sets: ${s}`);const i=[];for(let m=0;m<t.length;m++)i.push([]);for(const m of this.rotations){if(Math.abs(Math.abs(m.a)-1)<Z)continue;const M=m.makenormal();for(let $=0;$<t.length;$++)if(M.sameplane(e[$])){i[$].push(m);break}}this.moverotations=i;for(let m=0;m<i.length;m++){const M=i[m],$=M[0].makenormal();for(let j=0;j<M.length;j++)$.dist(M[j].makenormal())>Z&&(M[j]=M[j].smul(-1));M.sort((j,B)=>j.angle()-B.angle()),i[m][0].dot(e[m])<0&&M.reverse()}const n=i.map(m=>1+m.length);this.movesetorders=n;const o=[];let r="?";for(let m=0;m<t.length;m++){const M=e[m];let $=null,j=null;for(const B of this.geonormals){const z=M.dot(B[0]);Math.abs(z-1)<Z?(j=[B[1],B[2]],r=B[2]):Math.abs(z+1)<Z&&($=[B[1],B[2]],r=B[2])}if(j===null||$===null)throw new Error("Saw positive or negative sides as null");o.push([j[0],j[1],$[0],$[1],1+t[m].length]),this.addNotationMapper==="NxNxNCubeMapper"&&r==="f"&&(this.notationMapper=new Xt(1+t[m].length),this.addNotationMapper=""),this.addNotationMapper==="SkewbMapper"&&t[0].length===1&&(this.notationMapper=new ne(this.swizzler),this.addNotationMapper=""),this.addNotationMapper==="PyraminxOrTetraminxMapper"&&(t[0].length===2&&t[0][0].a===.333333333333333&&t[0][1].a===1.66666666666667?(this.notationMapper=new St(this.swizzler),this.addNotationMapper=""):(this.notationMapper=new te(this.swizzler),this.addNotationMapper="")),this.addNotationMapper==="MegaminxMapper"&&r==="f"&&(1+t[m].length===3&&(this.notationMapper=new Vt(this.notationMapper)),this.addNotationMapper=""),this.addNotationMapper==="FTOMapper"&&r==="f"&&(1+t[m].length===3&&(this.notationMapper=new Yt(this.notationMapper,this.swizzler)),this.addNotationMapper="")}this.movesetgeos=o;const b=new Map,l=this.faces;for(let m=0;m<l.length;m++){const M=l[m],$=this.keyface(M);if(!b.get($))b.set($,[m]);else{const j=b.get($);if(j.push(m),j.length===this.baseFaceCount){this.options.verbosity>0&&console.log("# Splitting core.");for(let B=0;B<j.length;B++){const z=`${$} ${B}`;b.set(z,[j[B]])}}}}this.facelisthash=b,this.options.verbosity>0&&console.log(`# Cubies: ${b.size}`);const u=[],v=[],g=[];for(const m of b.values())if(m.length!==this.baseFaceCount){if(m.length>1){const M=m.map(C=>l[C].centermass()),$=Bt(M);for(let C=0;m.length>2;C++){let A=!1;for(let P=0;P<m.length;P++){const K=(P+1)%m.length;if($.dot(M[P].cross(M[K]))<0){const V=M[P];M[P]=M[K],M[K]=V;const Q=m[P];m[P]=m[K],m[K]=Q,A=!0}}if(!A)break;if(C>1e3)throw new Error("Bad epsilon math; too close to border")}let j=0;for(const C of m)j|=1<<Math.floor(C/this.stickersperface);const B=this.markedface[j];let z=-1;for(let C=0;C<m.length;C++)Math.floor(m[C]/this.stickersperface)===B&&(z=C);if(z<0)throw new Error("Could not find marked face in list");if(z!==0){const C=m.slice();for(let A=0;A<m.length;A++)m[A]=C[(z+A)%m.length]}}for(let M=0;M<m.length;M++){const $=m[M];v[$]=u.length,g[$]=M}u.push(m)}this.cubies=u,this.facetocubie=v,this.facetoord=g;const f=["?","CENTERS","EDGES","CORNERS","C4RNER","C5RNER"],p=[],a=[0,0,0,0,0,0],d=[],F=[];let y=0;const x=[],R=[],D=[],S=[],H=m=>u[m].map(M=>this.getfaceindex(M)).join(" "),G=[];for(let m=0;m<u.length;m++){const M=u[m];if(M.length===0||F[m])continue;const $={};let j=0;D.push(0),G.push([]);const B=M.length,z=a[B]++;let C=f[B];(C===void 0||B===this.baseFaceCount)&&(C="CORE"),C=C+(z===0?"":z+1),p[y]=C,d[y]=B;const A=[m];let P=0;for(F[m]=!0;P<A.length;){const K=A[P++],V=H(K);if((M.length>1||$[V]===void 0)&&($[V]=j++),S[K]=$[V],x[K]=y,G[y].push(K),R[K]=D[y]++,A.length<this.rotations.length){const Q=this.facecentermass[u[K][0]];for(const q of i){const _=this.facetocubie[this.findface(Q.rotatepoint(q[0]))];F[_]||(A.push(_),F[_]=!0)}}}y++}if(this.setReidOrder&&4<=this.stickersperface&&this.stickersperface<=9){const m=[["UF","UR","UB","UL","DF","DR","DB","DL","FR","FL","BR","BL"],["UFR","URB","UBL","ULF","DRF","DFL","DLB","DBR"],["U","L","F","R","B","D"]],M={};for(const $ of m)for(let j=0;j<$.length;j++){let B=0;for(let z=0;z<$[j].length;z++)B|=1<<$[j].charCodeAt(z)-65;M[B]=j}for(const $ of G)for(const j of $){let B=0;for(const z of u[j])B|=1<<this.facenames[this.getfaceindex(z)][1].charCodeAt(0)-65;R[j]=M[B]}}if(this.cubiesetnums=x,this.cubieordnums=R,this.cubiesetnames=p,this.cubieords=D,this.orbitoris=d,this.cubievaluemap=S,this.cubiesetcubies=G,this.options.fixedPieceType!==null){for(let m=0;m<u.length;m++)if(this.options.fixedPieceType==="v"&&u[m].length>2||this.options.fixedPieceType==="e"&&u[m].length===2||this.options.fixedPieceType==="f"&&u[m].length===1){this.fixedCubie=m;break}if(this.fixedCubie<0)throw new Error(`Could not find a cubie of type ${this.options.fixedPieceType} to fix.`)}this.options.verbosity>0&&console.log(`# Cubie orbit sizes ${D}`)}unswizzle(t){const e=this.notationMapper.notationToInternal(t);return e===null?null:e.modified({family:this.swizzler.unswizzle(e.family)})}stringToBlockMove(t){const e=/^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$/,s=t.match(e);if(s===null)throw new Error(`Bad move passed ${t}`);const i=s[4];let n,o;if(s[2]!==void 0){if(s[3]===void 0)throw new Error("Missing second number in range");n=parseInt(s[2],10)}s[3]!==void 0&&(o=parseInt(s[3],10));let r="1",b=1;return s[5]!==void 0&&(r=s[5],r[0]==="'"&&(r=`-${r.substring(1)}`),b=parseInt(r,10)),new E(new N(i,o,n),b)}parseMove(t){const e=this.notationMapper.notationToInternal(t);if(e===null)throw new Error(`Bad move ${t.family}`);t=e;let s=t.family,i=!1;if(s.endsWith("v")&&s[0]<="Z"){if(t.innerLayer!==void 0||t.outerLayer!==void 0)throw new Error("Cannot use a prefix with full cube rotations");s=s.slice(0,-1),i=!0}s.endsWith("w")&&s[0]<="Z"&&(s=s.slice(0,-1).toLowerCase());let n,o=-1;const r=this.swizzler.unswizzle(s);let b=!1;for(let v=0;v<this.movesetgeos.length;v++){const g=this.movesetgeos[v];r===g[0]&&(b=!0,n=g,o=v),r===g[2]&&(b=!1,n=g,o=v)}let l=1,u=1;if(s.toUpperCase()!==s&&(u=2),n===void 0)throw new Error(`Bad grip in move ${t.family}`);if(t.outerLayer!==void 0&&(l=t.outerLayer),t.innerLayer!==void 0&&(t.outerLayer===void 0?(u=t.innerLayer,s<="Z"?l=u:l=1):u=t.innerLayer),l--,u--,i&&(l=0,u=this.moveplanesets[o].length),l<0||l>this.moveplanesets[o].length||u<0||u>this.moveplanesets[o].length)throw new Error(`Bad slice spec ${l} ${u} vs ${this.moveplanesets[o].length}`);if(l===0&&u===this.moveplanesets[o].length&&!i)throw new Error("! full puzzle rotations must be specified with v suffix.");return[void 0,o,l,u,b,t.amount]}parsemove(t){const e=this.parseMove(this.stringToBlockMove(t));return e[0]=t,e}genperms(){if(this.cmovesbyslice.length>0)return;const t=[];if(this.options.orientCenters){for(let e=0;e<this.cubies.length;e++)if(this.cubies[e].length===1){const s=this.cubies[e][0],i=this.getfaceindex(s),n=this.basefaces[i].centermass();if(n.dist(this.facecentermass[s])<Z){const o=1<<i|1<<this.baseFaceCount,r=this.markedface[o],b=this.baseplanes[r].makenormal();let l=-1,u=-1;for(let f=0;f<this.faces[s].length;f++){const p=this.faces[s].get(f),a=b.dot(p.sub(n));a>l&&(l=a,u=f)}const v=(u+1)%this.faces[s].length;if(Math.abs(b.dot(this.faces[s].get(v).sub(n))-l)<Z&&(u=v),u!==0){const f=[];for(let p=0;p<this.faces[s].length;p++)f.push(this.faces[s].get((p+u)%this.faces[s].length));this.faces[s]=new lt(f)}const g=this.basefaces[i].length;for(let f=1;f<g;f++)this.cubies[e].push(this.cubies[e][f-1]);this.duplicatedFaces[s]=g,this.duplicatedCubies[e]=g,this.orbitoris[this.cubiesetnums[e]]=g}}}for(let e=0;e<this.moveplanesets.length;e++){const s=this.moveplanesets[e],i=[],n=[s.length+1,0];let o=1;for(;o*2<=s.length;)o*=2;for(let l=0;l<this.faces.length;l++){let u=0;if(s.length>0){const v=this.facecentermass[l].dot(s[0]);for(let g=o;g>0;g>>=1)u+g<=s.length&&v>s[u+g-1].a&&(u+=g);u=s.length-u}for(i.push(u);n.length<=u;)n.push(0);n[u]++}const r=new Array(n.length);for(let l=0;l<n.length;l++)r[l]=[];const b=[];for(let l=0;l<this.faces.length;l++){if(i[l]<0)continue;const u=[this.facetocubie[l],this.facetoord[l]];let v=this.facecentermass[l];const g=v;let f=l;const p=i[f];for(;;){i[f]=-1;const a=v.rotatepoint(this.moverotations[e][0]);if(a.dist(g)<Z)break;f=this.findface(a),u.push(this.facetocubie[f],this.facetoord[f]),v=a}if(u.length>2&&this.options.orientCenters&&(this.cubies[u[0]].length===1||this.duplicatedCubies[u[0]]>1)&&this.facecentermass[l].dist(this.basefaces[this.getfaceindex(l)].centermass())<Z){let a=this.faces[this.cubies[u[0]][0]];for(let d=0;d<u.length;d+=2){const F=this.faces[this.cubies[u[d]][0]];let y=-1;for(let x=0;x<a.length;x++)if(F.get(x).dist(a.get(0))<Z){y=x;break}if(y<0)throw new Error("Couldn't find rotation of center faces; ignoring for now.");u[d+1]=y,a=a.rotate(this.moverotations[e][0])}}if(u.length===2&&this.options.orientCenters){const a=this.facecentermass[l].dot(this.moveplanenormals[e]);for(let d=1;d<this.movesetorders[e];d++)a>0?u.push(u[0],d):u.push(u[0],(this.movesetorders[e]-d)%this.movesetorders[e])}if(u.length>2&&!b[u[0]]){if(u.length!==2*this.movesetorders[e])throw new Error("Bad length in perm gen");for(const a of u)r[p].push(a)}for(let a=0;a<u.length;a+=2)b[u[a]]=!0}for(let l=0;l<r.length;l++)r[l]=r[l].slice();t.push(r)}if(this.cmovesbyslice=t,this.options.moveList){const e=[];for(const s of this.options.moveList)e.push(this.parsemove(s));this.parsedmovelist=e}this.facelisthash.clear(),this.facecentermass=[]}getboundarygeometry(){return{baseplanes:this.baseplanes,facenames:this.facenames,faceplanes:this.faceplanes,vertexnames:this.vertexnames,edgenames:this.edgenames,geonormals:this.geonormals}}getmovesets(t){const e=this.moveplanesets[t].length;let s=[];if(this.parsedmovelist!==void 0)for(const i of this.parsedmovelist)i[1]===t&&(i[4]?s.push([i[2],i[3]]):s.push([e-i[3],e-i[2]]),s.push(i[5]));else if(this.options.vertexMoves&&!this.options.allMoves){const i=this.movesetgeos[t];if(i[1]!==i[3])for(let n=0;n<e;n++)i[1]!=="v"?(this.options.outerBlockMoves?s.push([n+1,e]):s.push([n+1]),s.push(1)):(this.options.outerBlockMoves?s.push([0,n]):s.push([n,n]),s.push(1))}else for(let i=0;i<=e;i++)!this.options.allMoves&&i+i===e||(this.options.outerBlockMoves?i+i>e?s.push([i,e]):s.push([0,i]):s.push([i,i]),s.push(1));if(this.fixedCubie>=0){const i=this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[t],n=[];for(let o=0;o<s.length;o+=2){let r=s[o];if(i>=r[0]&&i<=r[1])if(r[0]===0)r=[r[1]+1,e];else if(e===r[1])r=[0,r[0]-1];else throw Error("fixed cubie option would disconnect move");let b=!1;for(let l=0;l<n.length;l+=2)if(n[l][0]===r[0]&&n[l][1]===r[1]&&n[l+1]===s[o+1]){b=!0;break}b||(n.push(r),n.push(s[o+1]))}s=n}return s}graybyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),e===1&&(this.options.grayCenters||!this.options.includeCenterOrbits)||e===2&&(this.options.grayEdges||!this.options.includeEdgeOrbits)||e>2&&(this.options.grayCorners||!this.options.includeCornerOrbits)}skipbyori(t){let e=this.cubies[t].length;return this.duplicatedCubies[t]&&(e=1),e===1&&!this.options.includeCenterOrbits||e===2&&!this.options.includeEdgeOrbits||e>2&&!this.options.includeCornerOrbits}skipcubie(t){return this.skipbyori(t)}header(t){return`${t+Le}
${t}
`}writegap(){const t=this.getOrbitsDef(!1),e=[],s=[];for(let n=0;n<t.moveops.length;n++){let o=`M_${ut(this.notationMapper,t.movenames[n])}`,r=!1;o[o.length-1]==="'"&&(o=o.substring(0,o.length-1),r=!0),s.push(o),r?e.push(`${o}:=${t.moveops[n].toPerm().inv().toGap()};`):e.push(`${o}:=${t.moveops[n].toPerm().toGap()};`)}e.push("Gen:=["),e.push(s.join(",")),e.push("];");const i=t.solved.identicalPieces();return e.push(`ip:=[${i.map(n=>`[${n.map(o=>o+1).join(",")}]`).join(",")}];`),e.push("# Size(Group(Gen));"),e.push("# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));"),e.push(""),this.header("# ")+e.join(`
`)}writemathematica(){const t=this.getOrbitsDef(!1),e=[],s=[];e.push(`(* ${this.header("").trim()} *)`);for(let i=0;i<t.moveops.length;i++){let n=`m${ut(this.notationMapper,t.movenames[i])}`,o=!1;n[n.length-1]==="'"&&(n=n.substring(0,n.length-1),o=!0),s.push(n),o?e.push(`${n}=${t.moveops[i].toPerm().inv().toMathematica()};`):e.push(`${n}=${t.moveops[i].toPerm().toMathematica()};`)}return e.push(`gen={${s.join(",")}};`),e.join(`
`)}writeksolve(t="PuzzleGeometryPuzzle"){const e=this.getOrbitsDef(!1);return this.header("# ")+e.toKsolve(t,this.notationMapper).join(`
`)}getKPuzzleDefinition(t=!0,e=!0){const i=this.getOrbitsDef(t,e).toKPuzzleDefinition(e);if(i.experimentalPuzzleDescription=this.puzzleDescription,!i)throw new Error("Missing definition!");return i}getMoveFromBits(t,e,s,i,n,o){const r=[],b=[],l=[];for(const g of this.cubieords)b.push(nt(g)),l.push(rt(g));for(let g=t[0];g<=t[1];g++){const f=i[g];for(let p=0;p<f.length;p+=2*o){const a=f.slice(p,p+2*o),d=this.cubiesetnums[a[0]];for(let x=0;x<a.length;x+=2)a[x]=this.cubieordnums[a[x]];let F=2,y=3;s&&(F=a.length-2,y=a.length-1),b[d]===nt(this.cubieords[d])&&(b[d]=b[d].slice(),this.orbitoris[d]>1&&!this.options.fixedOrientation&&(l[d]=l[d].slice()));for(let x=0;x<a.length;x+=2)b[d][a[(x+F)%a.length]]=a[x],this.orbitoris[d]>1&&!this.options.fixedOrientation&&(l[d][a[x]]=(a[(x+y)%a.length]-a[(x+1)%a.length]+2*this.orbitoris[d])%this.orbitoris[d])}}let u=new it(nt(24),rt(24),1);for(let g=0;g<this.cubiesetnames.length;g++)if(!(n&&!n[g]))if(this.orbitoris[g]===1||this.options.fixedOrientation)b[g]===nt(u.perm.length)?(b[g]!==u.perm&&(u=new it(b[g],l[g],1)),r.push(u)):r.push(new it(b[g],l[g],1));else{const f=new Array(l[g].length);for(let p=0;p<b[g].length;p++)f[p]=l[g][b[g][p]];r.push(new it(b[g],f,this.orbitoris[g]))}let v=new at(r);return e!==1&&(v=v.mulScalar(e)),v}omitSet(t){for(const e of this.options.excludeOrbits)if(e===t)return!0;return!1}diffmvsets(t,e,s,i){for(let n=0;n<t.length;n+=2){let o=!1;for(let r=0;!o&&r<e.length;r+=2)i?t[n][0]+e[r][1]===s&&t[n][1]+e[r][0]===s&&t[n+1]===e[r+1]&&(o=!0):t[n][0]===e[r][0]&&t[n][1]===e[r][1]&&t[n+1]===e[r+1]&&(o=!0);if(!o)return!0}return!1}getOrbitsDef(t,e=!0){const s=[];if(t)for(let a=0;a<this.cubiesetnames.length;a++)s.push(1);const i=[],n=[],o=[],r=[];for(let a=0;a<this.moveplanesets.length;a++){const d=this.getmovesets(a);o.push(d),this.options.addRotations?r.push(1):r.push(0)}const b=[];for(let a=0;a<this.moveplanesets.length;a++){const d=this.moveplanesets[a].length;let F=!1;const y=o[a];for(let x=0;x<y.length;x+=2)y[x][0]===0&&y[x][1]===d&&(F=!0);b[a]=F}if(this.options.addRotations&&(this.options.moveList||this.options.fixedPieceType!==null)){for(let a=0;a<this.moverotations.length;a++)r[a]=0;for(let a=0;a<this.moveplanesets.length;a++){if(b[a]){r[a]=3;continue}for(let d=0;d<this.moverotations.length;d++){let F=this.moveplanenormals[a];for(let y=1;y*2<=this.movesetorders[d];y++){if(F=F.rotatepoint(this.moverotations[d][0]),r[d]&y)continue;let x=-1,R=!1;for(let S=0;S<this.moveplanenormals.length;S++)if(F.dist(this.moveplanenormals[S])<Z){x=S;break}else if(F.dist(this.moveplanenormals[S].smul(-1))<Z){x=S,R=!0;break}if(x<0)throw new Error("Could not find rotation");const D=o[x];(D.length!==o[a].length||this.moveplanesets[a].length!==this.moveplanesets[x].length||this.diffmvsets(D,o[a],this.moveplanesets[x].length,R))&&(r[d]|=y)}}}for(let a=0;a<this.moverotations.length;a++)if(r[a]===0)r[a]=1;else if(r[a]===1)this.movesetorders[a]>3?r[a]=2:r[a]=0;else if(r[a]===3)r[a]=0;else throw new Error("Impossible addrot val")}for(let a=0;a<this.moveplanesets.length;a++)r[a]!==0&&!b[a]&&(o[a].push([0,this.moveplanesets[a].length]),o[a].push(r[a]));for(let a=0;a<this.moveplanesets.length;a++){const d=o[a],F=this.movesetorders[a];for(let R=0;R<d.length;R+=2)for(let D=0;D<R;D+=2)if(d[R][0]===d[D][0]&&d[R][1]===d[D][1])throw new Error("Redundant moves in moveset.");const y=[];for(let R=0;R<d.length;R+=2)for(let D=d[R][0];D<=d[R][1];D++)y[D]=1;const x=this.cmovesbyslice[a];for(let R=0;R<x.length;R++){if(y[R]!==1)continue;const D=x[R];for(let S=0;S<D.length;S+=2*F){if(this.skipcubie(D[S]))continue;const H=this.cubiesetnums[D[S]];s[H]=1}}}for(let a=0;a<this.cubiesetnames.length;a++)if(s[a]){if(this.omitSet(this.cubiesetnames[a])){s[a]=0;continue}i.push(this.cubiesetnames[a]),n.push(new Mt(this.cubieords[a],this.options.fixedOrientation?1:this.orbitoris[a]))}const l=[];for(let a=0;a<this.cubiesetnames.length;a++){if(!s[a]||this.omitSet(this.cubiesetnames[a]))continue;const d=[],F=[];for(let y=0;y<this.cubieords[a];y++){if(t)d.push(y);else{const x=this.cubiesetcubies[a][y];d.push(this.cubievaluemap[x])}F.push(0)}l.push(new it(d,F,this.options.fixedOrientation?1:this.orbitoris[a]))}const u=[],v=[],g=[],f=[];if(e)for(let a=0;a<this.moveplanesets.length;a++){const F=this.moveplanesets[a].length,y=o[a],x=this.movesetgeos[a];for(let R=0;R<y.length;R+=2){const D=y[R];let S,H=!1;if(this.parsedmovelist!==void 0)for(const m of this.parsedmovelist){if(m[1]!==a)continue;let M=[];m[4]?M=[m[2],m[3]]:M=[F-m[3],F-m[2]],M[0]===D[0]&&M[1]===D[1]&&(S=m[0],H=!m[4])}if(S)u.push(S),v.push(!0);else{const m=ze(x,D,F);H=m[1];const M=m[0];y[R+1]===1?u.push(M):u.push(M+y[R+1]),v.push(!1)}f.push(D[0]===0&&D[1]===F);const G=this.getMoveFromBits(D,y[R+1],H,this.cmovesbyslice[a],s,this.movesetorders[a]);g.push(G)}}let p=new dt(i,n,new gt(l),u,g,f,v);return this.options.optimizeOrbits&&(p=p.optimize()),this.options.scrambleAmount!==0&&p.scramble(this.options.scrambleAmount),p}getScramble(t=0){const e=this.getOrbitsDef(!1);return e.toKTransformationData(e.getScrambleTransformation(t))}getMovesAsPerms(){return this.getOrbitsDef(!1).moveops.map(t=>t.toPerm())}showcanon(t){fe(this.getOrbitsDef(!1),t)}getsolved(){const t=[];for(let e=0;e<this.baseFaceCount;e++)for(let s=0;s<this.stickersperface;s++)t.push(e);return new tt(t)}getOrientationRotation(t){const[e,[s,i,n]]=t[0],o=new O(0,s,-i,n),[r,[b,l,u]]=t[1],v=new O(0,b,-l,u);let g=null,f=null;const p=this.swizzler.unswizzle(e),a=this.swizzler.unswizzle(r);for(const x of this.geonormals)p===x[1]&&(g=x[0]),a===x[1]&&(f=x[0]);if(!g)throw new Error(`Could not find feature ${e}`);if(!f)throw new Error(`Could not find feature ${r}`);const d=g.pointrotation(o);return f.rotatepoint(d).unproject(o).pointrotation(v.unproject(o)).mul(d)}getInitial3DRotation(){const t=this.baseFaceCount;let e=null;if(this.options.puzzleOrientation?e=this.options.puzzleOrientation:this.options.puzzleOrientations&&(e=this.options.puzzleOrientations[t]),e||(e=Me()[t]),!e)throw new Error("No default orientation?");return this.getOrientationRotation(e)}generate2dmapping(t=800,e=500,s=10,i=!1,n=.92){t-=2*s,e-=2*s;function o(B,z){let C=B[1][0]-B[0][0],A=B[1][1]-B[0][1];const P=2*Math.PI/z,K=Math.cos(P),V=Math.sin(P);for(let Q=2;Q<z;Q++){const q=C*K+A*V;A=A*K-C*V,C=q,B.push([B[Q-1][0]+C,B[Q-1][1]+A])}}this.genperms();const l=this.getboundarygeometry().facenames[0][0].length,u=this.net;if(u===null)throw new Error("No net?");const v={};let g=0,f=0,p=1,a=0;v[u[0][0]]=[[1,0],[0,0]],o(v[u[0][0]],l);for(const B of u){const z=B[0];if(!v[z])throw new Error("Bad edge description; first edge not connected.");for(let C=1;C<B.length;C++){const A=B[C];A===""||v[A]||(v[A]=[v[z][C%l],v[z][(C+l-1)%l]],o(v[A],l))}}for(const B in v){const z=v[B];for(const C of z)g=Math.min(g,C[0]),p=Math.max(p,C[0]),f=Math.min(f,C[1]),a=Math.max(a,C[1])}const d=Math.min(t/(p-g),e/(a-f)),F=.5*(t-d*(p+g)),y=.5*(e-d*(a+f)),x={},R=this.getboundarygeometry(),D={},S=[[d+F,y],[F,y]];D[u[0][0]]=S,o(D[u[0][0]],l),x[this.facenames[0][1]]=this.project2d(0,0,[new O(0,S[0][0],S[0][1],0),new O(0,S[1][0],S[1][1],0)]);const H=[];H[0]=0;for(const B of u){const z=B[0];if(!D[z])throw new Error("Bad edge description; first edge not connected.");let C=-1;for(let P=0;P<R.facenames.length;P++)if(z===R.facenames[P][1]){C=P;break}if(C<0)throw new Error(`Could not find first face name ${z}`);const A=R.facenames[C][0];for(let P=1;P<B.length;P++){const K=B[P];if(K===""||D[K])continue;D[K]=[D[z][P%l],D[z][(P+l-1)%l]],o(D[K],l);const V=H[C],Q=A[(V+P)%l].sum(A[(V+P+l-1)%l]).smul(.5),q=ct(R.edgenames,Q),_=R.edgenames[q][1],Y=De(_,this.facenames),ht=Y[z===Y[0]?1:0];let et=-1;for(let W=0;W<R.facenames.length;W++)if(ht===R.facenames[W][1]){et=W;break}if(et<0)throw new Error("Could not find second face name");const st=R.facenames[et][0];for(let W=0;W<st.length;W++)if(st[W].sum(st[(W+1)%l]).smul(.5).dist(Q)<=Z){const L=D[z][(P+l-1)%l],U=D[z][P%l];H[et]=W,x[ht]=this.project2d(et,W,[new O(0,U[0],U[1],0),new O(0,L[0],L[1],0)]);break}}}let G=0,m=0;const M=this.getInitial3DRotation();for(let B of this.faces){i&&(B=B.rotate(M));for(let z=0;z<B.length;z++)G=Math.max(G,Math.abs(B.get(z).b)),m=Math.max(m,Math.abs(B.get(z).c))}const $=Math.min(e/m/2,(t-s)/G/4);return(B,z)=>{if(i){z=z.rotatepoint(M);const C=.5*s+.25*t,A=this.baseplanes[B].rotateplane(M).d<0?1:-1;return[s+t*.5+A*(C-z.b*$),s+e*.5+z.c*$]}else{const C=x[this.facenames[B][1]];return[s+n*z.dot(C[0])+C[2].b,s+e-n*z.dot(C[1])-C[2].c]}}}generatesvg(t=800,e=500,s=10,i=!1){const n=this.generate2dmapping(t,e,s,i);function o(g,f,p){return`<polygon id="${g}" class="sticker" style="fill: ${p}" points="${f.map(a=>`${a[0]} ${a[1]}`).join(" ")}"/>
`}const r=this.getsolved(),b=[],l=[];for(let g=0;g<this.baseFaceCount;g++)b[g]=this.colors[this.facenames[g][1]];for(let g=0;g<this.faces.length;g++){const f=this.faces[g],p=Math.floor(g/this.stickersperface),a=[];for(let d=0;d<f.length;d++)a.push(n(p,f.get(d)));l.push(a)}const u=[];for(let g=0;g<this.baseFaceCount;g++){u.push("<g>"),u.push(`<title>${this.facenames[g][1]}</title>
`);for(let f=0;f<this.stickersperface;f++){const p=g*this.stickersperface+f,a=this.facetocubie[p],d=this.facetoord[p],F=this.cubiesetnums[a],y=this.cubieordnums[a],x=this.graybyori(a)?"#808080":b[r.p[p]];let R=`${this.cubiesetnames[F]}-l${y}-o${d}`;if(u.push(o(R,l[p],x)),this.duplicatedFaces[p])for(let D=1;D<this.duplicatedFaces[p];D++)R=`${this.cubiesetnames[F]}-l${y}-o${D}`,u.push(o(R,l[p],x))}u.push("</g>")}return`<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">
<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>
${u.join("")}</svg>`}get3d(t){const e=[],s=this.getInitial3DRotation(),i=[],n=.52*this.basefaces[0].get(0).len();for(let l=0;l<this.basefaces.length;l++){const u=this.basefaces[l].rotate(s),v=this.facenames[l][1];i.push({coords:Ft(u,n),name:v})}for(let l=0;l<this.faces.length;l++){const u=Math.floor(l/this.stickersperface),v=this.facetocubie[l],g=this.facetoord[l],f=this.cubiesetnums[v],p=this.cubieordnums[v];let a=this.graybyori(v)?t!=null&&t.darkIgnoredOrbits?"#222222":"#808080":this.colors[this.facenames[u][1]];t!=null&&t.stickerColors&&(a=t.stickerColors[l]);const d=this.faces[l].rotate(s);e.push({coords:Ft(d,n),color:a,orbit:this.cubiesetnames[f],ord:p,ori:g,face:u});let F=d;if(this.duplicatedFaces[l]){const y=F.length/this.duplicatedFaces[l];for(let x=1;x<this.duplicatedFaces[l];x++){for(let R=0;R<y;R++)F=F.rotateforward();e.push({coords:Ft(F,n),color:a,orbit:this.cubiesetnames[f],ord:p,ori:x,face:u,isDup:!0})}}}const o=[];for(let l=0;l<this.movesetgeos.length;l++){const u=this.movesetgeos[l],v=this.movesetorders[l];for(const g of this.geonormals)u[0]===g[1]&&u[1]===g[2]&&(o.push({coordinates:ft(g[0].rotatepoint(s),1),quantumMove:new E(u[0]),order:v}),o.push({coordinates:ft(g[0].rotatepoint(s).smul(-1),1),quantumMove:new E(u[2]),order:v}))}const r=this.generate2dmapping(2880,2160,0,!1,1),b=(()=>{const l=s.invrot();return(u,v)=>{let g=new O(0,v[0]*n,-v[1]*n,v[2]*n);g=g.rotatepoint(l);const f=r(u,g);return f[0]/=2880,f[1]=1-f[1]/2160,f}})().bind(this);return{stickers:e,faces:i,axis:o,unswizzle:this.unswizzle.bind(this),notationMapper:this.notationMapper,textureMapper:{getuv:b}}}getGeoNormal(t){const e=this.getInitial3DRotation(),s=this.swizzler.unswizzle(t);for(const i of this.geonormals)if(s===i[1]){const n=ft(i[0].rotatepoint(e),1);return Math.abs(n[0])<Z&&Math.abs(n[2])<Z&&(n[0]=0,n[2]=1e-6),n}}getfaceindex(t){const e=this.stickersperface;return Math.floor(t/e)}textForTwizzleExplorer(){return`Faces ${this.baseplanerot.length}
Stickers per face ${this.stickersperface}
Short edge ${this.shortedge}
Cubies ${this.cubies.length}
Edge distance ${this.edgedistance}
Vertex distance ${this.vertexdistance}`}writeSchreierSims(t){const s=this.getOrbitsDef(!1).reassemblySize();t(`Reassembly size is ${s}`);const i=ye(this.getMovesAsPerms(),t),n=s/i;t(`Ratio is ${n}`)}}class Ne{constructor(t,e){w(this,"orbitNames");this.pg=t,this.orbitNames=e.orbitnames}lookupMove(t){const e=this.pg.parseMove(t);if(this.pg.parsedmovelist){let o=!1;for(const r of this.pg.parsedmovelist)r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]&&r[4]===e[4]&&(o=!0);if(!o)return null}let s=[e[2],e[3]];if(!e[4]){const o=this.pg.moveplanesets[e[1]].length;s=[o-e[3],o-e[2]]}const i=this.pg.getMoveFromBits(s,e[5],!e[4],this.pg.cmovesbyslice[e[1]],void 0,this.pg.movesetorders[e[1]]);return dt.transformToKTransformationData(this.orbitNames,i)}remapKPuzzleDefinition(t){return oe(t,this.pg.notationMapper)}}export{Oe as EXPERIMENTAL_PUZZLE_BASE_SHAPES,Pe as EXPERIMENTAL_PUZZLE_CUT_TYPES,Ne as ExperimentalPGNotation,ke as PuzzleGeometry,O as Quat,Ue as getPG3DNamedPuzzles,$e as getPuzzleDescriptionString,Re as getPuzzleGeometryByDesc,Ie as getPuzzleGeometryByName,Ce as parseOptions,Gt as parsePuzzleDescription,ye as schreierSims};
